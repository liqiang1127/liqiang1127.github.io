<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>HDU_LIQIANG&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写点什么呢~">
<meta property="og:type" content="website">
<meta property="og:title" content="HDU_LIQIANG&#39;s Blog">
<meta property="og:url" content="https://github.com/liqiang1127/index.html">
<meta property="og:site_name" content="HDU_LIQIANG&#39;s Blog">
<meta property="og:description" content="写点什么呢~">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="liqiang">
<meta property="article:tag" content="Java CV">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="HDU_LIQIANG&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HDU_LIQIANG&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Java Coder</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/liqiang1127"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-b-treeContains" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/17/b-treeContains/" class="article-date">
  <time datetime="2020-06-17T09:29:11.000Z" itemprop="datePublished">2020-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/b-treeContains/">mysql中3层的B+树能存多少条数据？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>InnoDB一棵B+树可以存放多少行数据？</code>这个问题的简单回答是：<code>约2千万</code>。为什么是这么多呢？因为这是可以算出来的，要搞清楚这个问题，我们先从InnoDB索引数据结构、数据组织方式说起。</p>
<p>在计算机中<code>磁盘</code>存储数据最小单元是<code>扇区</code>，一个扇区的大小是<code>512字节</code>，而<code>文件系统</code>（例如XFS/EXT4）他的最小单元是<code>块</code>，一个块的大小是<code>4k</code>，而对于我们的<code>InnoDB存储引擎</code>也有自己的最小储存单元——<code>页（Page）</code>，一个页的大小是<code>16K</code>。</p>
<p><strong>下面几张图可以帮你理解最小存储单元：</strong><br>文件系统中一个文件大小<code>只有1个字节</code>，但<code>不得不占磁盘上4KB的空间</code>。</p>
<img src="/2020/06/17/b-treeContains/pic1.png" class title="ss">

<p>innodb的所有数据文件（后缀为ibd的文件），他的大小始终都是<code>16384（16k）</code>的整数倍。<br>磁盘扇区、文件系统、InnoDB存储引擎都有各自的最小存储单元。在MySQL中我们的InnoDB页的大小默认是16k，<code>当然也可以通过参数设置</code>。</p>
<img src="/2020/06/17/b-treeContains/pic2.png" class title="ss">

<p>数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？<code>假设一行数据的大小是1k</code>，那么<code>一个页可以存放16行这样的数据</code>。</p>
<p>如果数据库只按这样的方式存储，那么如何查找数据就成为一个问题，因为我们不知道要查找的数据存在哪个页中，也不可能把所有的页遍历一遍，那样太慢了。所以人们想了一个办法，<code>用B+树的方式组织这些数据</code>。如图所示：</p>
<img src="/2020/06/17/b-treeContains/pic3.png" class title="ss">

<p>据记录按主键进行排序，分别存放在不同的页中（为了便于理解我们这里一个页中只存放3条记录，实际情况可以存放很多），除了存放<code>数据</code>的页以外，还有存放<code>键值+指针</code>的页，如图中<code>page number=3的页</code>，该页存放键值和指向数据页的指针，这样的页由N个键值+指针组成。当然它也是<code>排好序的</code>。这样的数据组织形式，我们称为索引组织表。现在来看下，要查找一条数据，怎么查？</p>
<p>比如执行如下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这里id是主键,我们通过这棵B+树来查找，首先找到根页，你怎么知道user表的根页在哪呢？其实每张表的根页位置在表空间文件中是固定的，即page number=3的页（这点我们下文还会进一步证明），找到根页后，通过<code>二分查找法</code>，定位到id=5的数据应该在指针P5指向的页中，那么进一步去page number=5的页中查找，同<code>样通过二分查询法</code>即可找到id=5的记录。</p>
<p><strong>现在我们清楚了InnoDB中主键索引B+树是如何组织数据、查询数据的，我们<code>总结一下</code>：</strong></p>
<p>1、InnoDB存储引擎的<code>最小存储单元是页</code>，页可以用于存放<code>数据</code>也可以用于存放<code>键值+指针</code>，在B+树中叶子节点存放数据，非叶子节点存放键值+指针。</p>
<p>2、索引组织表通过非叶子节点的<code>二分查找法</code>以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据；</p>
<p><strong>那么回到我们开始的问题，<code>通常一棵B+树可以存放多少行数据？</code></strong></p>
<p>这里我们<code>先假设B+树高为2</code>，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。</p>
<p>上文我们已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，<code>实际上</code>现在很多互联网业务<code>数据记录大小通常就是1K左右</code>）。</p>
<p>那么现在我们需要计算出<code>非叶子节点能存放多少指针</code>，其实这也很好算，我们假设<code>主键ID为bigint类型，长度为8字节</code>，而<code>指针大小</code>在InnoDB源码中设置为<code>6字节</code>，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即<code>16384/14=1170</code>。那么可以算出一棵<code>高度为2的B+树</code>，能存放<code>1170*16=18720条</code>这样的数据记录。</p>
<p>根据同样的原理我们可以算出一个<code>高度为3的B+树</code>可以存放：<code>1170*1170*16=21902400条</code>这样的记录。所以在InnoDB中<code>B+树高度一般为1-3层</code>，它就能<code>满足千万级的数据存储</code>。在查找数据时 <strong><code>一次页的查找代表一次IO</code></strong>， 所以通过主键索引查询通常 <strong><code>只需要1-3次IO操作</code></strong> 即可查找到数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/17/b-treeContains/" data-id="ckbj5svic0000jsug3sdq0opn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ConcurrentHashMap和HashTable" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/12/ConcurrentHashMap%E5%92%8CHashTable/" class="article-date">
  <time datetime="2020-06-12T09:15:28.000Z" itemprop="datePublished">2020-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/12/ConcurrentHashMap%E5%92%8CHashTable/">ConcurrentHashMap和HashTable</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/12/ConcurrentHashMap%E5%92%8CHashTable/" data-id="ckbj50tcc0000ocug1qqm07fi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mybatis核心组件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/10/Mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/" class="article-date">
  <time datetime="2020-06-10T06:06:40.000Z" itemprop="datePublished">2020-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/10/Mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/">Mybatis核心组件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mybatis操作数据"><a href="#Mybatis操作数据" class="headerlink" title="Mybatis操作数据"></a>Mybatis操作数据</h2><p>下面一段使用Mybatis操作数据库的常见代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testMybatis</span> <span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取配置文件输入流</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">        <span class="comment">// 通过SqlSessionFactoryBuilder的build()方法创建SqlSessionFactory实例</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        <span class="comment">// 调用openSession()方法创建SqlSession实例</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 获取UserMapper代理对象</span></span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 执行Mapper方法，获取执行结果</span></span><br><span class="line">        List&lt;UserEntity&gt; userList = userMapper.listAllUser();</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 兼容Ibatis，通过Mapper Id执行SQL操作</span></span><br><span class="line"><span class="comment">        List&lt;UserEntity&gt; userList = sqlSession.selectList(</span></span><br><span class="line"><span class="comment">                "com.blog4java.mybatis.com.blog4java.mybatis.example.mapper.UserMapper.listAllUser");</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(JSON.toJSONString(userList));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如上面的代码所示，<code>SqlSession</code>是<code>MyBatis</code>中提供与数据库交互的接口，<code>SqlSession</code>实例通过工厂模式创建。为了创建<code>SqlSession</code>对象，首先需要创建<code>SqlSessionFactory</code>对象，而<code>SqlSessionFactory</code>对象的创建依赖于<code>SqlSessionFactoryBuilder</code>类，该类提供了一系列重载的<code>build()</code>方法，我们需要以主配置文件的输入流作为参数调用<code>SqlSessionFactoryBuilder</code>的<code>build()</code>方法，以获取一个<code>SqlSessionFactory</code>对象。调用<code>SqlSessionFactory</code>对象的<code>openSession()</code>获取一个与数据库建立连接的<code>SqlSession</code>实例。然后调用<code>getMapper()</code>方法获取一个动态代理对象，然后通过代理实例的方法，完成与数据库的交互。</p>
<h2 id="Mybatis核心组件"><a href="#Mybatis核心组件" class="headerlink" title="Mybatis核心组件"></a>Mybatis核心组件</h2><p>上面接触Mybatis比较核心的一个组件<code>SqlSession</code>，它是Mybatis提供给用户操作数据库的API，那么MyBatis底层又是如何工作的呢？我准备了一张图，这里画出了Mybatis中一些比较核心的组件。</p>
<img src="/2020/06/10/Mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png" class title="核心组件">

<p>下面简单介绍这些核心组件：</p>
<ul>
<li><strong>Configuration</strong>：用户描述Mybatis的主配置信息，其他组件需要获取配置信息时，直接通过Configuration对象获取。除此以外，MyBatis在应用启动时，将Mapper配置信息，类型别名，TypeHandler等注册到Configuration组件中，其他组件需要的时候可以获取。</li>
<li><strong>MappedStatement</strong>：MappedStatement用于描述Mapper中的Sql配置信息，是对Mapper XML配置文件中&lt;select|update|delete|insert&gt;等标签或者@Select/@Update等注解配置信息的封装。</li>
<li><strong>SqlSession</strong>:SqlSession是MyBatis提供的面向用户API，表示和数据库交互式的会话对象，用于完成数据库的增删改查功能。SqlSession是Executor组件的外观，目的是对外提供易于理解和使用的数据库操作接口。</li>
<li><strong>Executor</strong>：Executor是MyBatis的Sql执行器，MyBatis中对数据库所有的增删改查操作都是由Executor组件完成的。</li>
<li><strong>StatementHandler</strong>：StatementHandler封装了对JDBC Statement的操作，比如为Statement对象设置参数，调用Statement接口提供的方法与数据库交互等。</li>
<li><strong>ParameterHandler</strong>：当MyBatis框架使用的Statement类型为PrepareStatement或CallableStatement时，ParameterHandler用于为Statement对象参数占位符设置值。</li>
<li><strong>ResultSetHandler</strong>：ResultSetHandler封装了对JDBC ResultSet对象的操作。用以返回Select语句查询到的Java对象。</li>
<li><strong>TypeHandler</strong>：TypeHandler完成getXXX和setXXX时的类型转换，完成数据库类型和Java类型的映射（或者反之）。</li>
</ul>
<h2 id="工作关键点"><a href="#工作关键点" class="headerlink" title="工作关键点"></a>工作关键点</h2><p>了解了Mybatis的核心组件以后，我们再简单分析一下数据库交互的关键点：</p>
<ol>
<li>获取<code>SqlSession</code>组件（获取这个过程第一节讲过了），它实际上是<code>Executor</code>组件的外观，提供给用户更加易用友好的接口，体现了设计模式的<strong>外观模式</strong>。</li>
<li>真正执行SQL操作的是<code>Executor</code>组件，可以理解它为执行器。</li>
<li><code>Executor</code>会使用<code>StatementHandler</code>组件对JDBC的<code>Statement</code>对象进行操作。如果<code>Statement</code>的类型是<code>PrepareStatement</code>或者<code>CallableStatement</code>，则会通过<code>ParameterHandler</code>为参数占位符进行赋值。</li>
<li><code>ParameterHandler</code>赋值的时候会找到Java类型对应的<code>TypeHandler</code>对象，<code>TypeHandler</code>会调用<code>Statement</code>对象提供的setXXX()方法对参数占位符设置值。</li>
<li><code>StatementHandler</code>使用JDBC的<code>Statement</code>对象与数据库完成交互以后，当执行的SQL为select，<code>ResultSetHandler</code>组件会从<code>Statement</code>对象中获取<code>ResultSet</code>对象它转换成Java对象，返回给上层。</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>接下来就是各个组件的具体解析，以后有机会再写。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/10/Mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/" data-id="ckb905ao70000okug636l2j65" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/09/HashMap/" class="article-date">
  <time datetime="2020-06-09T11:50:17.000Z" itemprop="datePublished">2020-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/09/HashMap/">HashMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HashMap总结（问答）"><a href="#HashMap总结（问答）" class="headerlink" title="HashMap总结（问答）"></a>HashMap总结（问答）</h2><blockquote>
<p> 好了我们开始今天的面试吧，小伙子你了解数据结构中的HashMap么？能跟我聊聊他的结构和底层原理么？</p>
</blockquote>
<p>嗯嗯面试官，我知道HashMap是我们非常常用的数据结构，由<strong>数组和链表组合构成</strong>的数据结构。</p>
<p>大概如下，数组里面每个地方都存了Key-Value这样的实例，在Java7叫Entry在Java8中叫Node。</p>
<img src="/2020/06/09/HashMap/p1.png" class title="ss">

<p>因为他本身所有的位置都为null，在put插入的时候会根据key的hash去计算一个index值。</p>
<p>就比如我put（”帅丙“，520），我插入了为”帅丙“的元素，这个时候我们会通过哈希函数计算出插入的位置，计算出来index是2那结果如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="string">"帅丙"</span>) = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<img src="/2020/06/09/HashMap/p2.png" class title="ss">

<hr>
<blockquote>
<p>你提到了还有链表，为啥需要链表，链表又是怎么样子的呢？</p>
</blockquote>
<p>我们都知道数组长度是有限的，在有限的长度里面我们使用哈希，哈希本身就存在率性，就是”帅丙“和”丙帅“我们都去hash有一定的概率会一样，就像上面的情况我再次哈希”丙帅“极端情况也会hash到一个值上，那就形成了链表。</p>
<img src="/2020/06/09/HashMap/p3.png" class title="ss">

<p>每一个节点都会保存自身的hash、key、value、以及下个节点，我看看Node的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>说到链表我想问一下，你知道新的Entry节点在插入链表的时候，是怎么插入的么？</p>
</blockquote>
<p><strong>Java8之前是头插法</strong>，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，就像上面的例子一样，因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。</p>
<p>但是，<strong>在Java8之后，都是所用尾部插入了。</strong>(原因是Java7中的头插法在并发情况下会导致rehash的时候成环)</p>
<p>数组容量是有限的，数据多次插入的，到达一定的数量就会进行扩容，也就是resize。</p>
<hr>
<blockquote>
<p>什么时候resize呢？</p>
</blockquote>
<p>有两个因素：</p>
<ul>
<li>Capacity：HashMap当前长度。</li>
<li>LoadFactor：负载因子，默认值0.75f。</li>
</ul>
<p>怎么理解呢，就比如当前的容量大小为100，当你存进第76个的时候，判断发现需要进行resize了，那就进行扩容，但是HashMap的扩容也不是简单的扩大点容量这么简单的。</p>
<hr>
<blockquote>
<p>扩容？它是怎么扩容的呢？</p>
</blockquote>
<p>分为两步</p>
<ul>
<li>扩容：创建一个新的Entry空数组，长度是原数组的2倍。</li>
<li>ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。</li>
</ul>
<hr>
<blockquote>
<p>为什么要重新Hash呢，直接复制过去不香么？</p>
</blockquote>
<p>是因为长度扩大以后，Hash的规则也随之改变。</p>
<p>Hash的公式—&gt; index = HashCode（Key） &amp; （Length - 1）</p>
<p>原来长度（Length）是8你位运算出来的值是2 ，新的长度是16你位运算出来的值明显不一样了。</p>
<p>扩容前：</p>
<img src="/2020/06/09/HashMap/p4.png" class title="ss">

<p>扩容后:</p>
<img src="/2020/06/09/HashMap/p5.png" class title="ss">

<hr>
<blockquote>
<p>说完扩容机制我们言归正传，为啥之前用头插法，java8之后改成尾插了呢？</p>
</blockquote>
<p>我先举个例子吧，我们现在往一个容量大小为2的put两个值，负载因子是0.75是不是我们在put第二个的时候就会进行resize？</p>
<p>2*0.75 = 1 所以插入第二个就要resize了</p>
<p>现在我们要在容量为2的容器里面<strong>用不同线程</strong>插入A，B，C，假如我们在resize之前打个短点，那意味着数据都插入了但是还没resize那扩容前可能是这样的。</p>
<p>我们可以看到链表的指向A-&gt;B-&gt;C</p>
<p><strong>Tip：A的下一个指针是指向B的</strong></p>
<img src="/2020/06/09/HashMap/p6.png" class title="ss">

<p>因为resize的赋值方式，也就是使用了<strong>单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置</strong>，在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>就可能出现下面的情况，大家发现问题没有？</p>
<p>B的下一个指针指向了A</p>
<img src="/2020/06/09/HashMap/p7.png" class title="ss">

<p>一旦几个线程都调整完成，就可能出现环形链表</p>
<img src="/2020/06/09/HashMap/p8.png" class title="ss">

<p>如果这个时候去取值，悲剧就出现了——Infinite Loop。</p>
<p><strong>使用头插</strong>会改变链表的上的顺序，但是如果<strong>使用尾插</strong>，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p>
<p>就是说原本是A-&gt;B，在扩容后那个链表还是A-&gt;B</p>
<img src="/2020/06/09/HashMap/p8.png" class title="ss">

<p>Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</p>
<p>Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</p>
<hr>
<blockquote>
<p>那是不是意味着Java8就可以把HashMap用在多线程中呢？</p>
</blockquote>
<p>我认为即使不会出现死循环，但是通过源码看到put/get方法都没有加同步锁，多线程情况最容易出现的就是：无法保证上一秒put的值，下一秒get的时候还是原值，所以线程安全还是无法保证。</p>
<hr>
<blockquote>
<p>那我问你HashMap的默认初始化长度是多少？</p>
</blockquote>
<p>我记得我在看源码的时候<strong>初始化大小是16</strong> (实际上hashMap的大小必须是2^n)，这个是因为定位index的时候，避免%操作，而使用&amp;，提高速度。</p>
<hr>
<blockquote>
<p>那为啥用16不用别的呢？</p>
</blockquote>
<p>因为在使用不是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。</p>
<p>只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。</p>
<p>这是为了<strong>实现均匀分布</strong>。</p>
<hr>
<blockquote>
<p>哟小家伙，知道的确实很多，那我问你个问题，为啥我们重写equals方法的时候需要重写hashCode方法呢？</p>
<p>你能用HashMap给我举个例子么？</p>
</blockquote>
<p>因为在java中，所有的对象都是继承于Object类。Ojbect类中有两个方法equals、hashCode，这两个方法都是用来比较两个对象是否相等的。</p>
<p>在未重写equals方法我们是继承了object的equals方法，<strong>那里的 equals是比较两个对象的内存地址</strong>，显然我们new了2个对象内存地址肯定不一样</p>
<ul>
<li>对于值对象，==比较的是两个对象的值</li>
<li>对于引用对象，比较的是两个对象的地址</li>
</ul>
<p>大家是否还记得我说的HashMap是通过key的hashCode去寻找index的，那index一样就形成链表了，也就是说”帅丙“和”丙帅“的index都可能是2，在一个链表上的。</p>
<p>我们去get的时候，他就是根据key去hash然后计算出index，找到了2，那我怎么找到具体的”帅丙“还是”丙帅“呢？</p>
<p><strong>equals</strong>！是的，所以如果我们对equals方法进行了重写，建议一定要对hashCode方法重写，以保证相同的对象返回相同的hash值，不同的对象返回不同的hash值。</p>
<p>不然一个链表的对象，你哪里知道你要找的是哪个，到时候发现hashCode都一样，这不是完犊子嘛。</p>
<hr>
<blockquote>
<p>可以可以小伙子，我记得你上面说过他是线程不安全的，那你能跟我聊聊你们是怎么处理HashMap在线程安全的场景么？</p>
</blockquote>
<p>面试官，在这样的场景，我们一般都会使用<strong>HashTable</strong>或者<strong>CurrentHashMap</strong>，但是因为前者的<strong>并发度</strong>的原因基本上没啥使用场景了，所以存在线程不安全的场景我们都使用的是CorruentHashMap。</p>
<p>HashTable我看过他的源码，很简单粗暴，直接在方法上锁，并发度很低，最多同时允许一个线程访问，currentHashMap就好很多了，1.7和1.8有较大的不同，不过并发度都比前者好太多了。</p>
<p>源码在此：(部分)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure the value is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>HashMap常见面试题：</p>
<ul>
<li>HashMap的底层数据结构？</li>
<li>HashMap的存取原理？</li>
<li>Java7和Java8的区别？</li>
<li>为啥会线程不安全？</li>
<li>有什么线程安全的类代替么?</li>
<li>默认初始化大小是多少？为啥是这么多？为啥大小都是2的幂？</li>
<li>HashMap的扩容方式？负载因子是多少？为什是这么多？</li>
<li>HashMap的主要参数都有哪些？</li>
<li>HashMap是怎么处理hash碰撞的？</li>
<li>hash的计算规则？</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/09/HashMap/" data-id="ckb7wchuh00007oug3dgw9dhk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Mysql和Redis双写一致性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/06/Mysql%E5%92%8CRedis%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/" class="article-date">
  <time datetime="2020-06-06T00:31:48.000Z" itemprop="datePublished">2020-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/06/Mysql%E5%92%8CRedis%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/">Mysql和Redis双写一致性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h2 id="为什么写这篇文章？"><a href="#为什么写这篇文章？" class="headerlink" title="为什么写这篇文章？"></a>为什么写这篇文章？</h2><p>首先，缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。</p>
<p>但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。目前没有一篇全面的博客，对这几种方案进行解析。于是博主战战兢兢，顶着被大家喷的风险，写了这篇文章。</p>
<h2 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h2><p>本文由以下三个部分组成 1、讲解缓存更新策略 2、对每种策略进行缺点分析 3、针对缺点给出改进方案</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。 在这里，我们讨论<strong>三种</strong>更新策略：</p>
<ul>
<li>\1. 先更新数据库，再更新缓存</li>
<li>\2. 先删除缓存，再更新数据库</li>
<li>\3. 先更新数据库，再删除缓存</li>
</ul>
<p>应该没人问我，为什么没有先更新缓存，再更新数据库这种策略。</p>
<h2 id="1-先更新数据库，再更新缓存"><a href="#1-先更新数据库，再更新缓存" class="headerlink" title="(1)先更新数据库，再更新缓存"></a>(1)先更新数据库，再更新缓存</h2><p>这套方案，大家是普遍反对的。为什么呢？有如下两点原因。</p>
<p><strong>原因一（线程安全角度）</strong> 同时有请求A和请求B进行更新操作，那么会出现</p>
<ul>
<li>（1）线程A更新了数据库</li>
<li>（2）线程B更新了数据库</li>
<li>（3）线程B更新了缓存</li>
<li>（4）线程A更新了缓存</li>
</ul>
<p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>
<p><strong>原因二（业务场景角度）</strong> 有如下两点：</p>
<ul>
<li>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</li>
<li>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</li>
</ul>
<p>接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。</p>
<h2 id="2-先删缓存，再更新数据库"><a href="#2-先删缓存，再更新数据库" class="headerlink" title="(2)先删缓存，再更新数据库"></a>(2)先删缓存，再更新数据库</h2><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>
<ul>
<li>（1）请求A进行写操作，删除缓存</li>
<li>（2）请求B查询发现缓存不存在</li>
<li>（3）请求B去数据库查询得到旧值</li>
<li>（4）请求B将旧值写入缓存</li>
<li>（5）请求A将新值写入数据库 上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</li>
</ul>
<p>那么，<strong>如何解决呢？采用延时双删策略</strong> 伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line">        redis.delKey(key);</span><br><span class="line">        db.updateData(data);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        redis.delKey(key);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>转化为中文描述就是</p>
<ul>
<li>（1）先淘汰缓存</li>
<li>（2）再写数据库（这两步和原来一样）</li>
<li>（3）休眠1秒，再次淘汰缓存 这么做，可以将1秒内所造成的缓存脏数据，再次删除。</li>
</ul>
<p><strong>那么，这个1秒怎么确定的，具体该休眠多久呢？</strong></p>
<p>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p><strong>如果你用了mysql的读写分离架构怎么办？</strong></p>
<p>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p>
<ul>
<li>（1）请求A进行写操作，删除缓存</li>
<li>（2）请求A将数据写入数据库了，</li>
<li>（3）请求B查询缓存发现，缓存没有值</li>
<li>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</li>
<li>（5）请求B将旧值写入缓存</li>
<li>（6）数据库完成主从同步，从库变为新值 上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</li>
</ul>
<p><strong>采用这种同步淘汰策略，吞吐量降低怎么办？</strong></p>
<p>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</p>
<p><strong>第二次删除,如果删除失败怎么办？</strong></p>
<p>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：</p>
<ul>
<li>（1）请求A进行写操作，删除缓存</li>
<li>（2）请求B查询发现缓存不存在</li>
<li>（3）请求B去数据库查询得到旧值</li>
<li>（4）请求B将旧值写入缓存</li>
<li>（5）请求A将新值写入数据库</li>
<li>（6）请求A试图去删除请求B写入对缓存值，结果失败了。 ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。 <strong>如何解决呢？</strong> 具体解决方案，且看博主对第(3)种更新策略的解析。</li>
</ul>
<h2 id="3-先更新数据库，再删缓存"><a href="#3-先更新数据库，再删缓存" class="headerlink" title="(3)先更新数据库，再删缓存"></a>(3)先更新数据库，再删缓存</h2><p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href="https://link.zhihu.com/?target=https%3A//docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">《Cache-Aside pattern》</a>。其中就指出</p>
<ol>
<li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li>
<li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ol>
<p>另外，知名社交网站facebook也在论文<a href="https://link.zhihu.com/?target=https%3A//www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf">《Scaling Memcache at Facebook》</a>中提出，他们用的也是先更新数据库，再删缓存的策略。</p>
<p><strong>这种情况不存在并发问题么？</strong></p>
<p>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p>
<p>（1）缓存刚好失效</p>
<p>（2）请求A查询数据库，得一个旧值</p>
<p>（3）请求B将新值写入数据库</p>
<p>（4）请求B删除缓存</p>
<p>（5）请求A将查到的旧值写入缓存 ok，如果发生上述情况，确实是会发生脏数据。</p>
<p><strong>然而，发生这种情况的概率又有多少呢？</strong></p>
<p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。</p>
<p>可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。 假设，有人非要抬杠，有强迫症，一定要解决怎么办？</p>
<p><strong>如何解决上述并发问题？</strong></p>
<p>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。</p>
<p><strong>还有其他造成不一致的原因么？</strong></p>
<p>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。</p>
<p><strong>如何解决？</strong> 提供一个保障的重试机制即可，这里给出两套方案。</p>
<p><strong>方案一</strong>： 如下图所示</p>
<img src="/2020/06/06/Mysql%E5%92%8CRedis%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/%E6%96%B9%E6%A1%88%E4%B8%80.jpg" class title="方案一">

<p>流程如下所示</p>
<ul>
<li>（1）更新数据库数据；</li>
<li>（2）缓存因为种种问题删除失败</li>
<li>（3）将需要删除的key发送至消息队列</li>
<li>（4）自己消费消息，获得需要删除的key</li>
<li>（5）继续重试删除操作，直到成功 然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。 </li>
<li><strong>方案二</strong>：</li>
</ul>
<img src="/2020/06/06/Mysql%E5%92%8CRedis%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/%E6%96%B9%E6%A1%88%E4%BA%8C.jpg" class title="方案二">

<p>流程如下图所示：</p>
<ul>
<li>（1）更新数据库数据</li>
<li>（2）数据库会将操作信息写入binlog日志当中</li>
<li>（3）订阅程序提取出所需要的数据以及key</li>
<li>（4）另起一段非业务代码，获得该信息</li>
<li>（5）尝试删除缓存操作，发现删除失败</li>
<li>（6）将这些信息发送至消息队列</li>
<li>（7）重新从消息队列中获得该数据，重试操作。</li>
</ul>
<p><strong>备注说明：</strong>上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文其实是对目前互联网中已有的一致性方案，进行了一个总结。对于先删缓存，再更新数据库的更新策略，还有方案提出维护一个内存队列的方式，博主看了一下，觉得实现异常复杂，没有必要，因此没有必要在文中给出。最后，希望大家有所收获。</p>
<blockquote>
<p>[Redis与Mysql双写一致性方案解析]（<a href="https://zhuanlan.zhihu.com/p/59167071" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59167071</a>)</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/06/Mysql%E5%92%8CRedis%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/" data-id="ckb34uyxy0000z4ugbcds1c56" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-适配器模式和装饰器模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/28/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-05-28T07:30:01.000Z" itemprop="datePublished">2020-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/28/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/">适配器模式、装饰者模式和代理模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-适配器模式"><a href="#1-适配器模式" class="headerlink" title="1.适配器模式"></a>1.适配器模式</h2><p>适配器模式的功能很好理解，就是把一个类的接口变成客户端所能接受的另一种接口，从使两个接口不匹配而无法在一起工作的类能在一起工作。<strong>说白了，适配器模式会产生新的接口</strong>。</p>
<h2 id="2-装饰器模式"><a href="#2-装饰器模式" class="headerlink" title="2.装饰器模式"></a>2.装饰器模式</h2><p>装饰器模式，顾名思义，就是将某个类重新装扮一下，使得它比原来更”漂亮“，或者功能上更加强大，这就是装饰器模式需要达到的目的。但是作为使用者还不应该感受到装饰前和装饰后，有什么不同，否则就破坏了类原有的结构了，所以装饰器模式要做到对被装饰类的使用者透明，这是对装饰器的一个要求。<strong>装饰器模式要在保留原有的接口的基础上进行功能上的增强。</strong></p>
<h2 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3.代理模式"></a>3.代理模式</h2><p>代理模式和装饰器模式比较相似，不过它们的倾向性不同，让别人帮助你做你并不关心的事情，叫<strong>代理模式</strong>。为让自己的能力增强，使得增强后的自己能够使用更多的方法，拓展在自己基础之上的功能的，叫<strong>装饰器模式</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/28/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" data-id="ckaqh61as0000ywug4d93hgn8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-同步与异步and阻塞与非阻塞" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/27/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5and%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/" class="article-date">
  <time datetime="2020-05-27T13:33:00.000Z" itemprop="datePublished">2020-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/27/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5and%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/">同步与异步and阻塞与非阻塞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-同步与异步"><a href="#1-同步与异步" class="headerlink" title="1.同步与异步"></a>1.同步与异步</h2><p>所谓的<strong>同步</strong>就是一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，所依赖的任务才能完成，这是一种<strong>可靠的任务序列</strong>。要成功都成功，要失败都失败，两个任务的状态可以保持一致。而<strong>异步</strong>不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以他是不可靠的任务序列。<strong>我们可以用打电话和发短信来很好的比喻同步与异步的操作。</strong></p>
<p>在涉及I/O处理时通常都会遇到是同步还是异步的处理方式的选择问题，因为同步与异步的I/O处理方式对调用者的影响很大，在数据库产品中都会遇到这个问题，因为I/O通常是一个非常耗时的操作，在一个任务序列中，I/O通常都是性能的瓶颈。但是同步与异步的处理方式对于可靠性的影响非常大，<strong>同步能够保证程序的可靠性，而异步可以提升程序的性能</strong>，必须在可靠性和性能之间保持平衡，去没有完美的解决方案。</p>
<h2 id="2-阻塞与非阻塞"><a href="#2-阻塞与非阻塞" class="headerlink" title="2.阻塞与非阻塞"></a>2.阻塞与非阻塞</h2><p>阻塞与非阻塞主要是从CPU的消耗上来说的，阻塞就是CPU停下来等待一个慢的操作完成以后，CPU才能继续完成其他工作。非阻塞就是在这个慢操作执行的过程中，CPU去完成其他工作，等这个慢操作完成时，CPU在接着完成后续的操作。虽然从表面上看，非阻塞的方式可以明显提高CPU的利用率，但是也带来另一种后果，就是系统线程切换的增加。增加的CPU使用时间能不能步长系统切换成本需要好好评估。</p>
<h2 id="3-两种方式的组合"><a href="#3-两种方式的组合" class="headerlink" title="3. 两种方式的组合"></a>3. 两种方式的组合</h2><table>
<thead>
<tr>
<th>组合方式<div style="width: 150pt"></div></th>
<th>性能分析</th>
</tr>
</thead>
<tbody><tr>
<td>同步阻塞</td>
<td>最常用的一种方法，也是最简单的，但是IO性能很一般，CPU大部分时间处于空闲状态。</td>
</tr>
<tr>
<td>同步非阻塞</td>
<td>提升IO性能的常用手段，就是将IO的阻塞改成非阻塞的方式，尤其是网络IO是长连接同时传输数据也不是很多啊的情况下，提升性能非常有效。<br>这种方式通常提升IO性能但是增加CPU的消耗，要考虑增加的IO性能能不能补偿CPU的消耗，也就是系统的瓶颈是在IO上还是CPU上。</td>
</tr>
<tr>
<td>异步阻塞</td>
<td>这种方式在分布式数据库中经常用到，例如，在一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，还有2~3份备份记录到其他机器上，这些备份记录通常采用的异步阻塞的方式写IO。<br>异步阻塞对网络IO能够提升效率，尤其是像上面这种同时写多份相同数据的情况下。</td>
</tr>
<tr>
<td>异步非阻塞</td>
<td>这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，集群之间的消息同步机制一般用这种IO组合方式。如Cassandra的Gossip通信机制就是采用异步非阻塞的方式。<br>它适合同时要传多份相同的数据到集群的不同的机器，同时数据的传输量虽然不大却非常频繁的情况。这种网络IO方式性能能达到最高。</td>
</tr>
</tbody></table>
<p>虽然异步和非阻塞能够提升IO的性能，但是也会带来一些额外的性能成本，例如，会增加线程数量从而增加CPU的消耗，同时也会使程序设计的复杂度的上升。如果设计得不合理反而会导致性能下降，在实际设计时要根据场景综合评估。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/27/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5and%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/" data-id="ckapf2vvz0000xcugfs3rfc1g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" rel="tag">网络通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM垃圾收集器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/26/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="article-date">
  <time datetime="2020-05-26T09:10:39.000Z" itemprop="datePublished">2020-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/26/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">JVM垃圾收集器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JVM垃圾收集器种类"><a href="#JVM垃圾收集器种类" class="headerlink" title="JVM垃圾收集器种类"></a>JVM垃圾收集器种类</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范并没有规定垃圾收集器应该如何实现，因此一般来说不同厂商，不同版本的虚拟机提供的垃圾收集器实现可能会有差别，一般会给出参数来让用户根据应用的特点来组合各个年代使用的收集器，主要有以下垃圾收集器</p>
<img src="/2020/05/26/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/1.png" class title="ss">

<ul>
<li>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge</li>
<li>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</li>
<li>同时在新老生代工作的垃圾回收器：G1</li>
</ul>
<p>图片中的垃圾收集器如果存在连线，则代表它们之间可以配合使用，接下来我们来看看各个垃圾收集器的具体功能。</p>
<h3 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h3><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p>Serial 收集器是工作在新生代的，单线程的垃圾收集器，单线程意味着它只会使用一个 CPU 或一个收集线程来完成垃圾回收，不仅如此，还记得我们上文提到的 STW 了吗，它在进行垃圾收集时，其他用户线程会暂停，直到垃圾收集结束，也就是说在 GC 期间，此时的应用不可用。</p>
<p>看起来单线程垃圾收集器不太实用，不过我们需要知道的任何技术的使用都不能脱离场景，在 <strong>Client 模式</strong>下，它简单有效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 单线程模式无需与其他线程交互，减少了开销，专心做 GC 能将其单线程的优势发挥到极致，另外在用户的桌面应用场景，分配给虚拟机的内存一般不会很大，收集几十甚至一两百兆（仅是新生代的内存，桌面应用基本不会再大了），STW 时间可以控制在一百多毫秒内，只要不是频繁发生，这点停顿是可以接受的，所以对于运行在 Client 模式下的虚拟机，Serial 收集器是新生代的默认收集器</p>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程，其他像收集算法,STW,对象分配规则，回收策略与 Serial 收集器完成一样，在底层上，这两种收集器也共用了相当多的代码，它的垃圾收集过程如下</p>
<img src="/2020/05/26/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/2.png" class title="ss">

<p>ParNew 主要工作在 Server 模式，我们知道服务端如果接收的请求多了，响应时间就很重要了，多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，所以是许多运行在 Server 模式下的虚拟机的首选新生代收集器，另一个与性能无关的原因是因为除了 Serial  收集器，<strong>只有它能与 CMS 收集器配合工作</strong>，CMS 是一个划时代的垃圾收集器，是真正意义上的<strong>并发收集器</strong>，它第一次实现了垃圾收集线程与用户线程（基本上）同时工作，它采用的是传统的 GC 收集器代码框架，与 Serial,ParNew 共用一套代码框架，所以能与这两者一起配合工作，而后文提到的 Parallel Scavenge 与 G1 收集器没有使用传统的 GC 收集器代码框架，而是另起炉灶独立实现的，另外一些收集器则只是共用了部分的框架代码,所以无法与 CMS 收集器一起配合工作。</p>
<p>在多 CPU 的情况下，由于 ParNew 的多线程回收特性，毫无疑问垃圾收集会更快，也能有效地减少 STW 的时间，提升应用的响应速度。</p>
<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器也是一个使用<strong>复制算法</strong>，<strong>多线程</strong>，工作于新生代的垃圾收集器，看起来功能和 ParNew 收集器一样，它有啥特别之处吗</p>
<p><strong>关注点不同</strong>，CMS 等垃圾收集器关注的是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）），也就是说 CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 Parallel Scavenge 收集器关注的是吞吐量，所以更适合做后台运算等不需要太多用户交互的任务。</p>
<p>Parallel Scavenge 收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数及直接设置吞吐量大小的 -XX:GCTimeRatio（默认99%）</p>
<p>除了以上两个参数，还可以用 Parallel Scavenge 收集器提供的第三个参数 -XX:UseAdaptiveSizePolicy，开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，只需要设置好基本的堆大小（-Xmx 设置最大堆）,以及最大垃圾收集时间与吞吐量大小，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。自适应策略也是 Parallel Scavenge  与 ParNew 的重要区别！</p>
<h3 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h3><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>上文我们知道， Serial 收集器是工作于新生代的单线程收集器，与之相对地，Serial Old 是工作于老年代的单线程收集器，此收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，则它还有两大用途：一种是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，另一种是作为 CMS 收集器的后备预案,在并发收集发生 Concurrent Mode Failure 时使用（后文讲述）,它与 Serial 收集器配合使用示意图如下</p>
<img src="/2020/05/26/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/3.png" class title="s">

<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理法，两者组合示意图如下,这两者的组合由于都是多线程收集器，真正实现了「吞吐量优先」的目标</p>
<img src="/2020/05/26/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/4.png" class title="s">

<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p>CMS 收集器是以实现最短 STW 时间为目标的收集器，如果应用很重视服务的响应速度，希望给用户最好的体验，则 CMS 收集器是个很不错的选择！</p>
<p>我们之前说老年代主要用标记整理法，而 CMS 虽然工作于老年代，但采用的是标记清除法，主要有以下四个步骤</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ol>
<img src="/2020/05/26/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/5.png" class title="s">

<p>从图中可以的看到初始标记和重新标记两个阶段会发生 STW，造成用户线程挂起，不过初始标记仅标记 GC Roots 能关联的对象，速度很快，并发标记是进行 GC Roots  Tracing 的过程，重新标记是为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，这一阶段停顿时间一般比初始标记阶段稍长，但<strong>远比并发标记时间短</strong>。</p>
<p>整个过程中耗时最长的是并发标记和标记清理，不过这两个阶段用户线程都可工作，所以不影响应用的正常使用，所以总体上看，可以认为 CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>但是 CMS 收集器远达不到完美的程度，主要有以下三个缺点</p>
<ul>
<li>CMS 收集器对 CPU 资源非常敏感  原因也可以理解，比如本来我本来可以有 10 个用户线程处理请求，现在却要分出 3 个作为回收线程，吞吐量下降了30%，CMS 默认启动的回收线程数是 （CPU数量+3）/ 4, 如果 CPU 数量只有一两个，那吞吐量就直接下降 50%,显然是不可接受的</li>
<li>CMS 无法处理浮动垃圾（Floating Garbage）,可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，由于在并发清理阶段用户线程还在运行，所以清理的同时新的垃圾也在不断出现，这部分垃圾只能在下一次 GC 时再清理掉（即浮云垃圾），同时在垃圾收集阶段用户线程也要继续运行，就需要预留足够多的空间要确保用户线程正常执行，这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用，JDK 1.5 默认当老年代使用了68%空间后就会被激活，当然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置，但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 <strong>Concurrent Mode Failure</strong> 失败，这时会启用 Serial Old 收集器来重新进行老年代的收集，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。</li>
<li>CMS 采用的是标记清除法，上文我们已经提到这种方法会产生大量的内存碎片，这样会给大内存分配带来很大的麻烦，如果无法找到足够大的连续空间来分配对象，将会触发 Full GC，这会影响应用的性能。当然我们可以开启 -XX:+UseCMSCompactAtFullCollection（默认是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理会导致 STW，停顿时间会变长，还可以用另一个参数 -XX:CMSFullGCsBeforeCompation 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的。</li>
</ul>
<h4 id="G1（Garbage-First）-收集器"><a href="#G1（Garbage-First）-收集器" class="headerlink" title="G1（Garbage First） 收集器"></a>G1（Garbage First） 收集器</h4><p>G1 收集器是面向服务端的垃圾收集器，被称为驾驭一切的垃圾回收器，主要有以下几个特点</p>
<ul>
<li>像 CMS 收集器一样，能与应用程序线程并发执行。</li>
<li>整理空闲空间更快。</li>
<li>需要 GC 停顿时间更好预测。</li>
<li>不会像 CMS 那样牺牲大量的吞吐性能。</li>
<li>不需要更大的 Java Heap</li>
</ul>
<p>与 CMS 相比，它在以下两个方面表现更出色</p>
<ol>
<li>运作期间不会产生内存碎片，G1 从整体上看采用的是标记-整理法，局部（两个 Region）上看是基于复制算法实现的，两个算法都不会产生内存碎片，收集后提供规整的可用内存，这样有利于程序的长时间运行。</li>
<li>在 STW 上建立了<strong>可预测</strong>的停顿时间模型，用户可以指定期望停顿时间，G1 会将停顿时间控制在用户设定的停顿时间以内。</li>
</ol>
<p>为什么G1能建立可预测的停顿模型呢，主要原因在于 G1 对堆空间的分配与传统的垃圾收集器不一器，传统的内存分配就像我们前文所述，是连续的，分成新生代，老年代，新生代又分 Eden,S0,S1,如下</p>
<img src="/2020/05/26/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/6.png" class title="s">

<p>而 G1 各代的存储地址不是连续的，每一代都使用了 n 个不连续的大小相同的 Region，每个Region占有一块连续的虚拟内存地址，如图示</p>
<img src="/2020/05/26/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/7.png" class title="s">

<p>除了和传统的新老生代，幸存区的空间区别，Region还多了一个H，它代表Humongous，这表示这些Region存储的是巨大对象（humongous object，H-obj），即大小大于等于region一半的对象，这样超大对象就直接分配到了老年代，防止了反复拷贝移动。那么 G1 分配成这样有啥好处呢？</p>
<p>传统的收集器如果发生 Full GC 是对整个堆进行全区域的垃圾收集，而分配成各个 Region 的话，方便 G1 跟踪各个 Region 里垃圾堆积的价值大小（回收所获得的空间大小及回收所需经验值），这样根据价值大小维护一个优先列表，根据允许的收集时间，优先收集回收价值最大的 Region,也就避免了整个老年代的回收，也就减少了 STW 造成的停顿时间。同时由于只收集部分 Region,可就做到了 STW 时间的可控。</p>
<p>G1 收集器的工作步骤如下</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ol>
<img src="/2020/05/26/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/8.png" class title="s">

<p>可以看到整体过程与 CMS 收集器非常类似，筛选阶段会根据各个 Region 的回收价值和成本进行排序，根据用户期望的 GC 停顿时间来制定回收计划。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简述了垃圾回收的原理与垃圾收集器的种类，相信大家对开头提的一些问题应该有了更深刻的认识，在生产环境中我们要根据<strong>不同的场景</strong>来选择垃圾收集器组合，如果是运行在桌面环境处于 Client 模式的，则用 Serial + Serial Old 收集器绰绰有余，如果需要响应时间快，用户体验好的，则用 ParNew + CMS 的搭配模式，即使是号称是「驾驭一切」的 G1，也需要根据吞吐量等要求适当调整相应的 JVM 参数，没有最牛的技术，只有最合适的使用场景，切记！</p>
<p>理论有了，下一篇我们会进入手动操作环节，我们会一起来动手操作一些 demo，做一些实验，来验证我们看到的一些现象，比如对象一般分配在新生代，什么情况下会直接到老年代，该怎么实验？发生了OOM，该用哪些工具调试呢？等等，敬请期待！</p>
<p>参考</p>
<p>堆外内存的回收机制分析 <a href="https://www.jianshu.com/p/35cf0f348275" target="_blank" rel="noopener">https://www.jianshu.com/p/35cf0f348275</a> </p>
<p>java调用本地方法–jni简介 <a href="https://blog.csdn.net/w1992wishes/article/details/80283403" target="_blank" rel="noopener">https://blog.csdn.net/w1992wishes/article/details/80283403</a> </p>
<p>咱们从头到尾说一次 Java 垃圾回收 <a href="https://mp.weixin.qq.com/s/pR7U1OTwsNSg5fRyWafucA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/pR7U1OTwsNSg5fRyWafucA</a> </p>
<p>深入理解 Java 虚拟机 </p>
<p>Java Hotspot G1 GC的一些关键技术 <a href="https://tech.meituan.com/2016/09/23/g1.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/09/23/g1.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/26/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" data-id="ckanpw82i0000m8ug3s24gnsu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TCP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/26/TCP/" class="article-date">
  <time datetime="2020-05-26T08:17:38.000Z" itemprop="datePublished">2020-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/26/TCP/">TCP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看过太多tcp相关文章，但是看完总是不过瘾，似懂非懂，反复考虑过后，我觉得是那些文章太过理论，看起来没有体感，所以吸收不了。 希望这篇文章能做到言简意赅，帮助大家透过案例来理解原理。</p>
<h2 id="tcp的特点"><a href="#tcp的特点" class="headerlink" title="tcp的特点"></a>tcp的特点</h2><p>这个大家基本都能说几句，面试的时候候选人也肯定会告诉你这些：</p>
<ul>
<li>三次握手</li>
<li>四次挥手</li>
<li>可靠连接</li>
<li>丢包重传</li>
</ul>
<p>但是我只希望大家记住一个核心的：<strong>tcp是可以可靠传输协议，它的所有特点都为这个可靠传输服务</strong>。</p>
<h3 id="那么tcp是怎么样来保障可靠传输呢？"><a href="#那么tcp是怎么样来保障可靠传输呢？" class="headerlink" title="那么tcp是怎么样来保障可靠传输呢？"></a>那么tcp是怎么样来保障可靠传输呢？</h3><p>tcp在传输过程中都有一个ack，接收方通过ack告诉发送方收到那些包了。这样发送方能知道有没有丢包，进而确定重传。</p>
<h3 id="tcp建连接的三次握手"><a href="#tcp建连接的三次握手" class="headerlink" title="tcp建连接的三次握手"></a>tcp建连接的三次握手</h3><p>来看一个java代码连接数据库的三次握手过程</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6d66dadecb72e11e3e5ab765c6c3ea2e.png" alt="img1"></p>
<p>三个红框表示建立连接的三次握手：</p>
<ul>
<li>第一步：client 发送 syn 到server 发起握手；</li>
<li>第二步：server 收到 syn后回复syn+ack给client；</li>
<li>第三步：client 收到syn+ack后，回复server一个ack表示收到了server的syn+ack（此时client的48287端口的连接已经是established）</li>
</ul>
<p>握手的核心目的是告知对方seq（绿框是client的初始seq，蓝色框是server 的初始seq），对方回复ack（收到的seq+包的大小），这样发送端就知道有没有丢包了。</p>
<p>握手的次要目的是告知和协商一些信息，图中黄框。</p>
<ul>
<li>MSS–最大传输包</li>
<li>SACK_PERM–是否支持Selective ack(用户优化重传效率）</li>
<li>WS–窗口计算指数（有点复杂的话先不用管）</li>
</ul>
<p><strong>这就是tcp为什么要握手建立连接，就是为了解决tcp的可靠传输。</strong></p>
<h3 id="tcp断开连接的四次挥手"><a href="#tcp断开连接的四次挥手" class="headerlink" title="tcp断开连接的四次挥手"></a>tcp断开连接的四次挥手</h3><p>再来看java连上mysql后，执行了一个SQL： select sleep(2); 然后就断开了连接</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b6f4a952cdf8ffbb8f6e9434d1432e05.png" alt="img2"></p>
<p>四个红框表示断开连接的四次挥手：</p>
<ul>
<li>第一步： client主动发送fin包给server</li>
<li>第二步： server回复ack（对应第一步fin包的ack）给client，表示server知道client要断开了</li>
<li>第三步： server发送fin包给client，表示server也可以断开了</li>
<li>第四部： client回复ack给server，表示既然双发都发送fin包表示断开，那么就真的断开吧</li>
</ul>
<h3 id="为什么握手三次、挥手四次"><a href="#为什么握手三次、挥手四次" class="headerlink" title="为什么握手三次、挥手四次"></a>为什么握手三次、挥手四次</h3><p>这个问题太恶心，面试官太喜欢问，其实他也许只能背诵：因为……。</p>
<p>我也不知道怎么回答。网上都说tcp是双向的，所以断开要四次。但是我认为建连接也是双向的（双向都协调告知对方自己的seq号），为什么不需要四次握手呢，所以网上说的不一定精准。</p>
<p>你再看三次握手的第二步发 syn+ack，如果拆分成两步先发ack再发syn完全也是可以的（效率略低），这样三次握手也变成四次握手了。</p>
<p>看起来挥手的时候多一次，主要是收到第一个fin包后单独回复了一个ack包，如果能回复fin+ack那么四次挥手也就变成三次了。 来看一个案例：</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/9db33f9304f8236b1ebcb215064bb2af.png" alt="img3"></p>
<p>图中第二个红框就是回复的fin+ack，这样四次挥手变成三次了（如果一个包就是一次的话）。</p>
<p>我的理解：之所以绝大数时候我们看到的都是四次挥手，是因为收到fin后，知道对方要关闭了，然后OS通知应用层要关闭啥的，这里应用层可能需要做些准备工作，有一些延时，所以先回ack，准备好了再发fin 。 握手过程没有这个准备过程所以可以立即发送syn+ack。</p>
<h3 id="ack-seq-len"><a href="#ack-seq-len" class="headerlink" title="ack=seq+len"></a>ack=seq+len</h3><p>ack总是seq+len（包的大小），这样发送方明确知道server收到那些东西了。</p>
<p>但是特例是三次握手和四次挥手，虽然len都是0，但是syn和fin都要占用一个seq号，所以这里的ack都是seq+1。</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/45c6d36ce8b17a5c0442e66fce002ab4.png" alt="img4"></p>
<p>看图中左边红框里的len+seq就是接收方回复的ack的数字，表示这个包接收方收到了。然后下一个包的seq就是前一个包的len+seq，依次增加，一旦中间发出去的东西没有收到ack就是丢包了，过一段时间（或者其他方式）触发重传，保障了tcp传输的可靠性。</p>
<h3 id="三次握手中协商的其它信息"><a href="#三次握手中协商的其它信息" class="headerlink" title="三次握手中协商的其它信息"></a>三次握手中协商的其它信息</h3><p>MSS 最大一个包中能传输的信息（不含tcp、ip包头），MSS+包头就是MTU（最大传输单元），如果MTU过大可能在传输的过程中被卡住过不去造成卡死（这个大小的包一直传输不过去），跟丢包还不一样。</p>
<p>SACK_PERM 用于丢包的话提升重传效率，比如client一次发了1、2、3、4、5 这5个包给server，实际server收到了 1、3、4、5这四个包，中间2丢掉了。这个时候server回复ack的时候，都只能回复2，表示2前面所有的包都收到了，给我发第二个包吧，如果server 收到3、4、5还是没有收到2的话，也是回复ack 2而不是回复ack 3、4、5、6的，表示快点发2过来。</p>
<p>但是这个时候client虽然知道2丢了，然后会重发2，但是不知道3、4、5有没有丢啊，实际3、4、5 server都收到了，如果支持sack，那么可以ack 2的时候同时告诉client 3、4、5都收到了，这样client重传的时候只重传2就可以，如果没有sack的话那么可能会重传2、3、4、5，这样效率就低了。</p>
<p>来看一个例子：</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/5322d0cf77a3a1ae6c87a972cc5843d0.png" alt></p>
<p>图中的红框就是SACK。</p>
<p>知识点：ack数字表示这个数字前面的数据<strong>都</strong>收到了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>tcp所有特性基本上核心都是为了<strong>可靠传输</strong>这个目标来服务的，然后有一些是出于优化性能的目的。</p>
<p>三次握手建连接的详细过程可以参考我这篇： <a href="http://jm.taobao.org/2017/05/25/525-1/" target="_blank" rel="noopener">关于TCP 半连接队列和全连接队列</a></p>
<p>后续希望再通过几个案例来深化一下上面的知识。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/26/TCP/" data-id="ckannzzmu0001xcugfq94e37l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" rel="tag">网络通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-socket的一些理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/26/socket%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/" class="article-date">
  <time datetime="2020-05-26T07:59:20.000Z" itemprop="datePublished">2020-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/26/socket%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/">socket的一些理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>要写网络程序就必须用Socket，这是程序员都知道的。而且，面试的时候，我们也会问对方会不会Socket编程？一般来说，很多人都会说，Socket编程基本就是listen，accept以及send，write等几个基本的操作。是的，就跟常见的文件操作一样，只要写过就一定知道。</p>
<p>对于网络编程，我们也言必称TCP/IP，似乎其它网络协议已经不存在了。对于TCP/IP，我们还知道TCP和UDP，前者可以保证数据的正确和可靠性，后者则允许数据丢失。最后，我们还知道，在建立连接前，必须知道对方的IP地址和端口号。除此，普通的程序员就不会知道太多了，很多时候这些知识已经够用了。最多，写服务程序的时候，会使用多线程来处理并发访问。</p>
<p>我们还知道如下几个事实：</p>
<ol>
<li>一个指定的端口号不能被多个程序共用。比如，如果IIS占用了80端口，那么Apache就不能也用80端口了</li>
<li>很多防火墙只允许特定目标端口的数据包通过</li>
<li>服务程序在listen某个端口并accept某个连接请求后，会生成一个新的socket来对该请求进行处理</li>
</ol>
<p>于是，一个困惑了我很久的问题就产生了。如果一个socket创建后并与80端口绑定后，是否就意味着该socket占用了80端口呢？如果是这样的，那么当其accept一个请求后，生成的新的socket到底使用的是什么端口呢（我一直以为系统会默认给其分配一个空闲的端口号）？如果是一个空闲的端口，那一定不是80端口了，于是以后的TCP数据包的目标端口就不是80了–防火墙一定会组织其通过的！实际上，我们可以看到，防火墙并没有阻止这样的连接，而且这是最常见的连接请求和处理方式。我的不解就是，为什么防火墙没有阻止这样的连接？它是如何判定那条连接是因为connet80端口而生成的？是不是TCP数据包里有什么特别的标志？或者防火墙记住了什么东西？</p>
<p>后来，我又仔细研读了TCP/IP的协议栈的原理，对很多概念有了更深刻的认识。比如，在TCP和UDP同属于传输层，共同架设在IP层（网络层）之上。而IP层主要负责的是在节点之间（End to End）的数据包传送，这里的节点是一台网络设备，比如计算机。因为IP层只负责把数据送到节点，而不能区分上面的不同应用，所以TCP和UDP协议在其基础上加入了端口的信息，端口于是标识的是一个节点上的一个应用。除了增加端口信息，UPD协议基本就没有对IP层的数据进行任何的处理了。而TCP协议还加入了更加复杂的传输控制，比如滑动的数据发送窗口（Slice Window），以及接收确认和重发机制，以达到数据的可靠传送。不管应用层看到的是怎样一个稳定的TCP数据流，下面传送的都是一个个的IP数据包，需要由TCP协议来进行数据重组。</p>
<p>所以，我有理由怀疑，防火墙并没有足够的信息判断TCP数据包的更多信息，除了IP地址和端口号。而且，我们也看到，所谓的端口，是为了区分不同的应用的，以在不同的IP包来到的时候能够正确转发。</p>
<p>TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。就像操作系统会提供标准的编程接口，比如Win32编程接口一样，TCP/IP也必须对外提供编程接口，这就是Socket编程接口–原来是这么回事啊！</p>
<p>在Socket编程接口里，设计者提出了一个很重要的概念，那就是socket。这个socket跟文件句柄很相似，实际上在BSD系统里就是跟文件句柄一样存放在一样的进程句柄表里。这个socket其实是一个序号，表示其在句柄表中的位置。这一点，我们已经见过很多了，比如文件句柄，窗口句柄等等。这些句柄，其实是代表了系统中的某些特定的对象，用于在各种函数中作为参数传入，以对特定的对象进行操作–这其实是C语言的问题，在C++语言里，这个句柄其实就是this指针，实际就是对象指针啦。</p>
<p>现在我们知道，socket跟TCP/IP并没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以，socket的出现只是可以更方便的使用TCP/IP协议栈而已，其对TCP/IP进行了抽象，形成了几个最基本的函数接口。比如create，listen，accept，connect，read和write等等。</p>
<p>现在我们明白，如果一个程序创建了一个socket，并让其监听80端口，其实是向TCP/IP协议栈声明了其对80端口的占有。以后，所有目标是80端口的TCP数据包都会转发给该程序（这里的程序，因为使用的是Socket编程接口，所以首先由Socket层来处理）。所谓accept函数，其实抽象的是TCP的连接建立过程。accept函数返回的新socket其实指代的是本次创建的连接，而一个连接是包括两部分信息的，一个是源IP和源端口，另一个是宿IP和宿端口。所以，accept可以产生多个不同的socket，而这些socket里包含的宿IP和宿端口是不变的，变化的只是源IP和源端口。这样的话，这些socket宿端口就可以都是80，而Socket层还是能根据源/宿对来准确地分辨出IP包和socket的归属关系，从而完成对TCP/IP协议的操作封装！而同时，放火墙的对IP包的处理规则也是清晰明了，不存在前面设想的种种复杂的情形。</p>
<p><strong>明白socket只是对TCP/IP协议栈操作的抽象，而不是简单的映射关系，这很重要！</strong></p>
<p><strong>TCP连接</strong></p>
<p>手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。</p>
<p>建立起一个TCP连接需要经过“三次握手”：</p>
<ul>
<li>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>
</ul>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开）</p>
<p><strong>SOCKET原理</strong></p>
<blockquote>
<p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p>
</blockquote>
<p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/26/socket%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/" data-id="ckanmquyk00007kugehei2g2g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" rel="tag">网络通信</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" rel="tag">网络通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 16px;">JVM</a> <a href="/tags/LeetCode/" style="font-size: 18px;">LeetCode</a> <a href="/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/Spring/" style="font-size: 14px;">Spring</a> <a href="/tags/mysql/" style="font-size: 20px;">mysql</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12px;">数据结构</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" style="font-size: 14px;">网络通信</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/17/b-treeContains/">mysql中3层的B+树能存多少条数据？</a>
          </li>
        
          <li>
            <a href="/2020/06/12/ConcurrentHashMap%E5%92%8CHashTable/">ConcurrentHashMap和HashTable</a>
          </li>
        
          <li>
            <a href="/2020/06/10/Mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/">Mybatis核心组件</a>
          </li>
        
          <li>
            <a href="/2020/06/09/HashMap/">HashMap</a>
          </li>
        
          <li>
            <a href="/2020/06/06/Mysql%E5%92%8CRedis%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/">Mysql和Redis双写一致性</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 liqiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>