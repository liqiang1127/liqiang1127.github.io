<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>HDU_LIQIANG&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写点什么呢~">
<meta property="og:type" content="website">
<meta property="og:title" content="HDU_LIQIANG&#39;s Blog">
<meta property="og:url" content="https://github.com/liqiang1127/index.html">
<meta property="og:site_name" content="HDU_LIQIANG&#39;s Blog">
<meta property="og:description" content="写点什么呢~">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="liqiang">
<meta property="article:tag" content="Java CV">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="HDU_LIQIANG&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HDU_LIQIANG&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Java Coder</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/liqiang1127"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JVM面试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2020-07-24T12:57:25.000Z" itemprop="datePublished">2020-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/">JVM面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="易混淆概念"><a href="#易混淆概念" class="headerlink" title="易混淆概念"></a>易混淆概念</h2><h3 id="对象在哪里分配？"><a href="#对象在哪里分配？" class="headerlink" title="对象在哪里分配？"></a>对象在哪里分配？</h3><p>数组和对象是堆上分配，由于 JIT 的存在，如果发现某些对象没有逃逸出方法，那么就有可能被优化成了栈上分配。</p>
<h3 id="CMS-是老年代垃圾回收器？"><a href="#CMS-是老年代垃圾回收器？" class="headerlink" title="CMS 是老年代垃圾回收器？"></a>CMS 是老年代垃圾回收器？</h3><p>初步印象是，但实际上不是。根据 CMS 的各个收集过程，它其实是一个涉及年轻代和老年代的综合性垃圾回收器。在很多文章和书籍的划分中，都将 CMS 划分为了老年代垃圾回收器，加上它主要作用于老年代，所以一般误认为是。</p>
<h3 id="常量池问题"><a href="#常量池问题" class="headerlink" title="常量池问题"></a>常量池问题</h3><p>常量池的表述有些模糊，在此细化一下，注意我们指的是 Java 7 版本之后。</p>
<p>JVM 中有多个常量池：</p>
<ul>
<li><p>字符串常量池，存放在堆上，也就是执行 intern 方法后存的地方，class 文件的静态常量池，如果是字符串，则也会被装到字符串常量池中。</p>
</li>
<li><p>运行时常量池，存放在方法区，属于元空间，是类加载后的一些存储区域，大多数是类中 constant_pool 的内容。</p>
</li>
<li><p>类文件常量池，也就是 constant_pool，这个是概念性的，并没有什么实际存储区域。</p>
</li>
</ul>
<p>在平常的交流过程中，聊的最多的是字符串常量池</p>
<h3 id="ZGC-支持的堆上限？"><a href="#ZGC-支持的堆上限？" class="headerlink" title="ZGC 支持的堆上限？"></a>ZGC 支持的堆上限？</h3><p>Java 13 增加到 16TB，Java 11 还是 4 TB，技术在发展，请保持关注。</p>
<h3 id="年轻代提升阈值动态计算的描述"><a href="#年轻代提升阈值动态计算的描述" class="headerlink" title="年轻代提升阈值动态计算的描述"></a>年轻代提升阈值动态计算的描述</h3><p>程序从年龄最小的对象开始累加，如果累加的对象大小，大于幸存区的一半，则将当前的对象 age 作为新的阈值，年龄大于此阈值的对象则直接进入老年代。</p>
<p>这里说的一半，是通过 TargetSurvivorRatio 参数进行设置的。</p>
<h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>虽然课程一直在强调，是基于 Java 8+ 版本进行讲解的，但还是有读者提到了永久代。这部分知识容易发生混淆，面试频率也很高，建议集中消化一下。</p>
<img src="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/s1.png" class title="ss">

<p>上面是第 02 课时中的一张图，注意左半部分是 Java 8 版本之前的内存区域，右半部分是 Java 8 的内存区域，主要区别就在 Perm 区和 Metaspace 区。</p>
<p>Perm 区属于堆，独立控制大小，在 Java 8 中被移除了（JEP122），原来的方法区就在这里；Metaspace 是非堆，默认空间无上限，方法区移动到了这里。</p>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="JVM-有哪些内存区域？（JVM-的内存布局是什么？"><a href="#JVM-有哪些内存区域？（JVM-的内存布局是什么？" class="headerlink" title="JVM 有哪些内存区域？（JVM 的内存布局是什么？)"></a>JVM 有哪些内存区域？（JVM 的内存布局是什么？)</h3><p>JVM 包含堆、元空间、Java 虚拟机栈、本地方法栈、程序计数器等内存区域，其中，堆是占用内存最大的一块，如下图所示。</p>
<img src="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/s2.jpg" class title="ss">

<h3 id="Java-的内存模型是什么？（JMM-是什么？）"><a href="#Java-的内存模型是什么？（JMM-是什么？）" class="headerlink" title="Java 的内存模型是什么？（JMM 是什么？）"></a>Java 的内存模型是什么？（JMM 是什么？）</h3><p>JVM 试图定义一种统一的内存模型，能将各种底层硬件以及操作系统的内存访问差异进行封装，使 Java 程序在不同硬件以及操作系统上都能达到相同的并发效果。它分为工作内存和主内存，线程无法对主存储器直接进行操作，如果一个线程要和另外一个线程通信，那么只能通过主存进行交换，如下图所示。</p>
<img src="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/s3.png" class title="ss">

<h3 id="JVM-垃圾回收时如何确定垃圾？什么是-GC-Roots？"><a href="#JVM-垃圾回收时如何确定垃圾？什么是-GC-Roots？" class="headerlink" title="JVM 垃圾回收时如何确定垃圾？什么是 GC Roots？"></a>JVM 垃圾回收时如何确定垃圾？什么是 GC Roots？</h3><p>JVM 采用的是可达性分析算法。JVM 是通过 GC Roots 来判定对象存活的，从 GC Roots 向下追溯、搜索，会产生一个叫做 Reference Chain 的链条。当一个对象不能和任何一个 GC Root 产生关系时，就判定为垃圾，如下图所示。</p>
<img src="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/s4.png" class title="ss">

<p>GC Roots 大体包括：</p>
<ul>
<li><p>活动线程相关的各种引用，比如虚拟机栈中 栈帧里的引用；</p>
</li>
<li><p>类的静态变量引用；</p>
</li>
<li><p>JNI 引用等。</p>
</li>
</ul>
<h3 id="能够找到-Reference-Chain-的对象，就一定会存活么？"><a href="#能够找到-Reference-Chain-的对象，就一定会存活么？" class="headerlink" title="能够找到 Reference Chain 的对象，就一定会存活么？"></a>能够找到 Reference Chain 的对象，就一定会存活么？</h3><p>不一定，还要看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候会被回收，但如果没有 Reference Chain 对象时，就一定会被回收。</p>
<h3 id="强引用、软引用、弱引用、虚引用是什么？"><a href="#强引用、软引用、弱引用、虚引用是什么？" class="headerlink" title="强引用、软引用、弱引用、虚引用是什么？"></a>强引用、软引用、弱引用、虚引用是什么？</h3><p>普通的对象引用关系就是强引用。</p>
<p>软引用用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。</p>
<p>弱引用对象相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。</p>
<p>虚引用是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来跟踪对象被垃圾回收的活动。</p>
<h3 id="你说你做过-JVM-参数调优和参数配置，请问如何查看-JVM-系统默认值"><a href="#你说你做过-JVM-参数调优和参数配置，请问如何查看-JVM-系统默认值" class="headerlink" title="你说你做过 JVM 参数调优和参数配置，请问如何查看 JVM 系统默认值"></a>你说你做过 JVM 参数调优和参数配置，请问如何查看 JVM 系统默认值</h3><p>使用 -XX:+PrintFlagsFinal 参数可以看到参数的默认值，这个默认值还和垃圾回收器有关，比如 UseAdaptiveSizePolicy。</p>
<h3 id="你平时工作中用过的-JVM-常用基本配置参数有哪些？"><a href="#你平时工作中用过的-JVM-常用基本配置参数有哪些？" class="headerlink" title="你平时工作中用过的 JVM 常用基本配置参数有哪些？"></a>你平时工作中用过的 JVM 常用基本配置参数有哪些？</h3><p>主要有 Xmx、Xms、Xmn、MetaspaceSize 等。</p>
<p>更加详细的可参照第 23 课时的参数总结，你只需要记忆 10 个左右即可，建议记忆 G1 相关的参数。面试时间有限，不会在这上面纠结，除非你表现的太嚣张了。</p>
<h3 id="请你谈谈对-OOM-的认识"><a href="#请你谈谈对-OOM-的认识" class="headerlink" title="请你谈谈对 OOM 的认识"></a>请你谈谈对 OOM 的认识</h3><p>OOM 是非常严重的问题，除了程序计数器，其他内存区域都有溢出的风险。和我们平常工作最密切的，就是堆溢出，另外，元空间在加载的类非常多的情况下也会溢出，还有就是栈溢出，这个通常影响比较小。堆外也有溢出的可能，这个就比较难排查了。</p>
<h3 id="你都有哪些手段用来排查内存溢出？"><a href="#你都有哪些手段用来排查内存溢出？" class="headerlink" title="你都有哪些手段用来排查内存溢出？"></a>你都有哪些手段用来排查内存溢出？</h3><p>内存溢出包含很多种情况，我在平常工作中遇到最多的就是堆溢出。有一次线上遇到故障，重新启动后，使用 jstat 命令，发现 Old 区一直在增长。我使用 jmap 命令，导出了一份线上堆栈，然后使用 MAT 进行分析，通过对 GC Roots 的分析，发现了一个非常大的 HashMap 对象，这个原本是其他同事做缓存用的，但是一个无界缓存，造成了堆内存占用一直上升，后来，将这个缓存改成 guava 的 Cache，并设置了弱引用，故障就消失了。</p>
<h3 id="GC-垃圾回收算法与垃圾收集器的关系？"><a href="#GC-垃圾回收算法与垃圾收集器的关系？" class="headerlink" title="GC 垃圾回收算法与垃圾收集器的关系？"></a>GC 垃圾回收算法与垃圾收集器的关系？</h3><p>常用的垃圾回收算法有标记清除、标记整理、复制算法等，引用计数器也算是一种，但垃圾回收器不使用这种算法，因为有循环依赖的问题。</p>
<img src="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/s5.jpg" class title="ss">

<p>很多垃圾回收器都是分代回收的：</p>
<ul>
<li><p>对于年轻代，主要有 Serial、ParNew 等垃圾回收器，回收过程主要使用复制算法；</p>
</li>
<li><p>老年代的回收算法有 Serial、CMS 等，主要使用标记清除、标记整理算法等。</p>
</li>
</ul>
<p>我们线上使用较多的是 G1，也有年轻代和老年代的概念，不过它是一个整堆回收器，它的回收对象是小堆区 。</p>
<h3 id="生产上如何配置垃圾收集器？"><a href="#生产上如何配置垃圾收集器？" class="headerlink" title="生产上如何配置垃圾收集器？"></a>生产上如何配置垃圾收集器？</h3><img src="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/s6.png" class title="ss">

<p>首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。通常，堆空间我会设置成操作系统的 2/3，超过 8GB 的堆，优先选用 G1。</p>
<p>然后我会对 JVM 进行初步优化，比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例。</p>
<p>接下来是专项优化，判断的主要依据是系统容量、访问延迟、吞吐量等，我们的服务是高并发的，所以对 STW 的时间非常敏感。</p>
<p>我会通过记录详细的 GC 日志，来找到这个瓶颈点，借用 GCeasy 这样的日志分析工具，很容易定位到问题。</p>
<h3 id="怎么查看服务器默认的垃圾回收器是哪一个？"><a href="#怎么查看服务器默认的垃圾回收器是哪一个？" class="headerlink" title="怎么查看服务器默认的垃圾回收器是哪一个？"></a>怎么查看服务器默认的垃圾回收器是哪一个？</h3><p>这通常会使用另外一个参数，即 -XX:+PrintCommandLineFlags，来打印所有的参数，包括使用的垃圾回收器。</p>
<h3 id="假如生产环境-CPU-占用过高，请谈谈你的分析思路和定位。"><a href="#假如生产环境-CPU-占用过高，请谈谈你的分析思路和定位。" class="headerlink" title="假如生产环境 CPU 占用过高，请谈谈你的分析思路和定位。"></a>假如生产环境 CPU 占用过高，请谈谈你的分析思路和定位。</h3><img src="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/s7.jpg" class title="ss">

<p>首先，使用 top -H 命令获取占用 CPU 最高的线程，并将它转化为十六进制。</p>
<p>然后，使用 jstack 命令获取应用的栈信息，搜索这个十六进制，这样就能够方便地找到引起 CPU 占用过高的具体原因。</p>
<h3 id="对于-JDK-自带的监控和性能分析工具用过哪些？"><a href="#对于-JDK-自带的监控和性能分析工具用过哪些？" class="headerlink" title="对于 JDK 自带的监控和性能分析工具用过哪些？"></a>对于 JDK 自带的监控和性能分析工具用过哪些？</h3><ul>
<li><p>jps：用来显示 Java 进程；</p>
</li>
<li><p>jstat：用来查看 GC；</p>
</li>
<li><p>jmap：用来 dump 堆；</p>
</li>
<li><p>jstack：用来 dump 栈；</p>
</li>
<li><p>jhsdb：用来查看执行中的内存信息。</p>
</li>
</ul>
<h3 id="栈帧都有哪些数据？"><a href="#栈帧都有哪些数据？" class="headerlink" title="栈帧都有哪些数据？"></a>栈帧都有哪些数据？</h3><p>栈帧包含：局部变量表、操作数栈、动态连接、返回地址等。</p>
<img src="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/s8.jpg" class title="ss">

<h3 id="JIT-是什么？"><a href="#JIT-是什么？" class="headerlink" title="JIT 是什么？"></a>JIT 是什么？</h3><p>为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器，就称为即时编译器（Just In Time Compiler），简称 JIT 编译器。</p>
<h3 id="Java-的双亲委托机制是什么？"><a href="#Java-的双亲委托机制是什么？" class="headerlink" title="Java 的双亲委托机制是什么？"></a>Java 的双亲委托机制是什么？</h3><p>双亲委托的意思是，除了顶层的启动类加载器以外，其余的类加载器，在加载之前，都会委派给它的父加载器进行加载，这样一层层向上传递，直到祖先们都无法胜任，它才会真正的加载，Java 默认是这种行为。</p>
<img src="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/s9.png" class title="ss">

<h3 id="有哪些打破了双亲委托机制的案例？"><a href="#有哪些打破了双亲委托机制的案例？" class="headerlink" title="有哪些打破了双亲委托机制的案例？"></a>有哪些打破了双亲委托机制的案例？</h3><ul>
<li><p>Tomcat 可以加载自己目录下的 class 文件，并不会传递给父类的加载器；</p>
</li>
<li><p>Java 的 SPI，发起者是 BootstrapClassLoader，BootstrapClassLoader 已经是最上层了，它直接获取了 AppClassLoader 进行驱动加载，和双亲委派是相反的。</p>
</li>
</ul>
<h3 id="简单描述一下（分代）垃圾回收的过程"><a href="#简单描述一下（分代）垃圾回收的过程" class="headerlink" title="简单描述一下（分代）垃圾回收的过程"></a>简单描述一下（分代）垃圾回收的过程</h3><img src="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/s10.jpg" class title="ss">

<p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占总空间的 1/3，老生代的默认占比是 2/3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1。</p>
<p>当年轻代中的 Eden 区分配满的时候，就会触发年轻代的 GC（Minor GC），具体过程如下：</p>
<ul>
<li>在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区（以下简称 from）；</li>
<li>Eden 区再次 GC，这时会采用复制算法，将 Eden 和 from 区一起清理，存活的对象会被复制到 to 区，接下来，只要清空 from 区就可以了。</li>
</ul>
<h3 id="CMS-分为哪几个阶段"><a href="#CMS-分为哪几个阶段" class="headerlink" title="CMS 分为哪几个阶段?"></a>CMS 分为哪几个阶段?</h3><ul>
<li><p>初始标记</p>
</li>
<li><p>并发标记</p>
</li>
<li><p>并发预清理</p>
</li>
<li><p>并发可取消的预清理</p>
</li>
<li><p>重新标记</p>
</li>
<li><p>并发清理</p>
</li>
</ul>
<h3 id="CMS-都有哪些问题？"><a href="#CMS-都有哪些问题？" class="headerlink" title="CMS 都有哪些问题？"></a>CMS 都有哪些问题？</h3><ul>
<li><p>内存碎片问题，Full GC 的整理阶段，会造成较长时间的停顿；</p>
</li>
<li><p>需要预留空间，用来分配收集阶段产生的“浮动垃圾”；</p>
</li>
<li><p>使用更多的 CPU 资源，在应用运行的同时进行堆扫描；</p>
</li>
<li><p>停顿时间是不可预期的。</p>
</li>
</ul>
<h3 id="你使用过-G1-垃圾回收器的哪几个重要参数？"><a href="#你使用过-G1-垃圾回收器的哪几个重要参数？" class="headerlink" title="你使用过 G1 垃圾回收器的哪几个重要参数？"></a>你使用过 G1 垃圾回收器的哪几个重要参数？</h3>

<p>最重要的是 MaxGCPauseMillis，可以通过它设定 G1 的目标停顿时间，它会尽量去达成这个目标。G1HeapRegionSize 可以设置小堆区的大小，一般是 2 的次幂。InitiatingHeapOccupancyPercent 启动并发 GC 时的堆内存占用百分比，G1 用它来触发并发 GC 周期，基于整个堆的使用率，而不只是某一代内存的使用比例，默认是 45%。</p>
<h3 id="GC-日志的-real、user、sys-是什么意思？"><a href="#GC-日志的-real、user、sys-是什么意思？" class="headerlink" title="GC 日志的 real、user、sys 是什么意思？"></a>GC 日志的 real、user、sys 是什么意思？</h3><ul>
<li><p>real 指的是从开始到结束所花费的时间，比如进程在等待 I/O 完成，这个阻塞时间也会被计算在内。</p>
</li>
<li><p>user 指的是进程在用户态（User Mode）所花费的时间，只统计本进程所使用的时间，是指多核。</p>
</li>
<li><p>sys  指的是进程在核心态（Kernel Mode）所花费的 CPU 时间量，即内核中的系统调用所花费的时间，只统计本进程所使用的时间。</p>
</li>
</ul>
<h3 id="什么情况会造成元空间溢出？"><a href="#什么情况会造成元空间溢出？" class="headerlink" title="什么情况会造成元空间溢出？"></a>什么情况会造成元空间溢出？</h3><p>元空间默认是没有上限的，不加限制比较危险。当应用中的 Java 类过多时，比如 Spring 等一些使用动态代理的框架生成了很多类，如果占用空间超出了我们的设定值，就会发生元空间溢出。</p>
<h3 id="什么时候会造成堆外内存溢出？"><a href="#什么时候会造成堆外内存溢出？" class="headerlink" title="什么时候会造成堆外内存溢出？"></a>什么时候会造成堆外内存溢出？</h3><p>使用了 Unsafe 类申请内存，或者使用了 JNI 对内存进行操作，这部分内存是不受 JVM 控制的，不加限制使用的话，会很容易发生内存溢出。</p>
<h3 id="SWAP-会影响性能么？"><a href="#SWAP-会影响性能么？" class="headerlink" title="SWAP 会影响性能么？"></a>SWAP 会影响性能么？</h3><p>当操作系统内存不足时，会将部分数据写入到 SWAP ，但是 SWAP 的性能是比较低的。如果应用的访问量较大，需要频繁申请和销毁内存，那么很容易发生卡顿。一般在高并发场景下，会禁用 SWAP。</p>
<h3 id="有什么堆外内存的排查思路？"><a href="#有什么堆外内存的排查思路？" class="headerlink" title="有什么堆外内存的排查思路？"></a>有什么堆外内存的排查思路？</h3><p>进程占用的内存，可以使用 top 命令，看 RES 段占用的值，如果这个值大大超出我们设定的最大堆内存，则证明堆外内存占用了很大的区域。</p>
<p> 使用 gdb 命令可以将物理内存 dump 下来，通常能看到里面的内容。更加复杂的分析可以使用 Perf 工具，或者谷歌开源的 GPerftools。那些申请内存最多的 native 函数，就很容易找到。</p>
<h3 id="HashMap-中的-key，可以是普通对象么？有什么需要注意的地方？"><a href="#HashMap-中的-key，可以是普通对象么？有什么需要注意的地方？" class="headerlink" title="HashMap 中的 key，可以是普通对象么？有什么需要注意的地方？"></a>HashMap 中的 key，可以是普通对象么？有什么需要注意的地方？</h3><p>Map 的 key 和 value 可以是任何类型，但要注意的是，一定要重写它的 equals 和 hashCode 方法，否则容易发生内存泄漏。</p>
<h3 id="怎么看死锁的线程？"><a href="#怎么看死锁的线程？" class="headerlink" title="怎么看死锁的线程？"></a>怎么看死锁的线程？</h3><p>通过 jstack 命令，可以获得线程的栈信息，死锁信息会在非常明显的位置（一般是最后）进行提示。</p>
<h3 id="volatile-关键字的原理是什么？有什么作用？"><a href="#volatile-关键字的原理是什么？有什么作用？" class="headerlink" title="volatile 关键字的原理是什么？有什么作用？"></a>volatile 关键字的原理是什么？有什么作用？</h3><p>使用了 volatile 关键字的变量，每当变量的值有变动的时候，都会将更改立即同步到主内存中；而如果某个线程想要使用这个变量，就先要从主存中刷新到工作内存，这样就确保了变量的可见性。</p>
<p>一般使用一个 volatile 修饰的 bool 变量，来控制线程的运行状态。</p>
<h3 id="什么是方法内联？"><a href="#什么是方法内联？" class="headerlink" title="什么是方法内联？"></a>什么是方法内联？</h3><p>为了减少方法调用的开销，可以把一些短小的方法，比如 getter/setter，纳入到目标方法的调用范围之内，这样就少了一次方法调用，速度就能得到提升，这就是方法内联的概念。</p>
<h3 id="对象是怎么从年轻代进入老年代的？"><a href="#对象是怎么从年轻代进入老年代的？" class="headerlink" title="对象是怎么从年轻代进入老年代的？"></a>对象是怎么从年轻代进入老年代的？</h3><p>在下面 4 种情况下，对象会从年轻代进入到老年代。</p>
<ul>
<li><p>如果对象够老，则会通过提升（Promotion）的方式进入老年代，一般根据对象的年龄进行判断。</p>
</li>
<li><p>动态对象年龄判定，有的垃圾回收算法，比如 G1，并不要求 age 必须达到 15 才能晋升到老年代，它会使用一些动态的计算方法。</p>
</li>
<li><p>分配担保，当 Survivor 空间不够的时候，则需要依赖其他内存（指老年代）进行分配担保，这个时候，对象也会直接在老年代上分配。</p>
</li>
<li><p>超出某个大小的对象将直接在老年代上分配，不过这个值默认为 0，意思是全部首选 Eden 区进行分配。</p>
</li>
</ul>
<img src="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/12.jpg" class title="ss">

<h3 id="safepoint-是什么？"><a href="#safepoint-是什么？" class="headerlink" title="safepoint 是什么？"></a>safepoint 是什么？</h3><p>当发生 GC 时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为 JVM 是安全的（safe），整个堆的状态是稳定的。</p>
<img src="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/13.jpg" class title="ss">

<p>如果在 GC 前，有线程迟迟进入不了 safepoint，那么整个 JVM 都在等待这个阻塞的线程，造成了整体 GC 的时间变长。</p>
<h3 id="MinorGC、MajorGC、FullGC-都什么时候发生？"><a href="#MinorGC、MajorGC、FullGC-都什么时候发生？" class="headerlink" title="MinorGC、MajorGC、FullGC 都什么时候发生？"></a>MinorGC、MajorGC、FullGC 都什么时候发生？</h3><p>MinorGC 在年轻代空间不足的时候发生，MajorGC 指的是老年代的 GC，出现 MajorGC 一般经常伴有 MinorGC。</p>
<p>FullGC 有三种情况：第一，当老年代无法再分配内存的时候；第二，元空间不足的时候；第三，显示调用 System.gc 的时候。另外，像 CMS 一类的垃圾回收器，在 MinorGC 出现 promotion failure 的时候也会发生 FullGC。</p>
<h3 id="类加载有几个过程？"><a href="#类加载有几个过程？" class="headerlink" title="类加载有几个过程？"></a>类加载有几个过程？</h3><p>加载、验证、准备、解析、初始化。</p>
<img src="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/14.png" class title="ss">

<h3 id="什么情况下会发生栈溢出？"><a href="#什么情况下会发生栈溢出？" class="headerlink" title="什么情况下会发生栈溢出？"></a>什么情况下会发生栈溢出？</h3><p>栈的大小可以通过 -Xss 参数进行设置，当递归层次太深的时候，则会发生栈溢出。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本课时我们首先修正了一些表述错误的知识点；然后分析了一些常见的面试题，这些面试题的覆盖率是非常有限的，因为很多细节都没有触及到，更多的面试题还需要你自行提取、整理，由于篇幅有限，这里不再重复。</p>
<p>到现在为止，我们的课程内容就结束了。本课程的特色主要体现在实践方面，全部都是工作中的总结和思考；辅之以理论，给你一个在工作中，JVM 相关知识点的全貌。当然，有些课时的难度是比较高的，需要你真正的实际操作一下。</p>
<p>写作的过程中难免会有遗漏的知识点，可通过拉勾客服人员加入本课程的读者群一起讨论；如果你觉得课程不错，从中有所收获的话，不要忘了推荐给身边的朋友哦。前路漫漫，一起加油。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="ckd0akox00000zwug9avs9l1z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="psot-数据库设计三范式" class="article article-type-psot" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/" class="article-date">
  <time datetime="2020-06-28T06:31:13.000Z" itemprop="datePublished">2020-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/">数据库设计三范式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式"></a>数据库设计三范式</h1><h2 id="1-原子性范式"><a href="#1-原子性范式" class="headerlink" title="1.原子性范式"></a>1.原子性范式</h2><p>1NF是对属性的原子性，要求属性具有原子性，不可再分解；</p>
<blockquote>
<p>表：字段1、 字段2(字段2.1、字段2.2)、字段3 ……</p>
</blockquote>
<p>如学生（学号，姓名，性别，出生年月日），如果认为最后一列还可以再分成（出生年，出生月，出生日），它就不是一范式了，否则就是；</p>
<h2 id="2-唯一性范式"><a href="#2-唯一性范式" class="headerlink" title="2.唯一性范式"></a>2.唯一性范式</h2><p>2NF是对记录的惟一性，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；</p>
<blockquote>
<p>表：学号、课程号、姓名、学分;</p>
</blockquote>
<p>这个表明显说明了两个事务:学生信息, 课程信息;由于非主键字段必须依赖主键，这里学分依赖课程号，姓名依赖与学号，所以不符合二范式。</p>
<p>可能会存在问题：</p>
<ul>
<li>数据冗余:，每条记录都含有相同信息；</li>
<li>删除异常：删除所有学生成绩，就把课程信息全删除了；</li>
<li>插入异常：学生未选课，无法记录进数据库；<br>更新异常：调整课程学分，所有行都调整。</li>
</ul>
<p><strong>正确做法:</strong><br>学生：Student(学号, 姓名)；<br>课程：Course(课程号, 学分)；<br>选课关系：StudentCourse(学号, 课程号, 成绩)。</p>
<h2 id="3-冗余性范式"><a href="#3-冗余性范式" class="headerlink" title="3.冗余性范式"></a>3.冗余性范式</h2><p>3NF是对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；</p>
<blockquote>
<p>表: 学号, 姓名, 年龄, 学院名称, 学院电话</p>
</blockquote>
<p>因为存在依赖传递: (学号) → (学生)→(所在学院) → (学院电话) 。</p>
<p>可能会存在问题：</p>
<ul>
<li>数据冗余:有重复值；</li>
<li>更新异常：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况 。</li>
</ul>
<p><strong>正确做法：</strong></p>
<p>学生：(学号，姓名，年龄，所在学院)</p>
<p>学院：(学院, 电话)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/" data-id="ckbypaklc00007gug09fm2u4w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-applicationContext中的Refresh-方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/24/applicationContext%E4%B8%AD%E7%9A%84Refresh-%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2020-06-24T08:41:41.000Z" itemprop="datePublished">2020-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/24/applicationContext%E4%B8%AD%E7%9A%84Refresh-%E6%96%B9%E6%B3%95/">applicationContext中的Refresh()方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><strong>refresh()</strong>，该方法是 Spring Bean 加载的核心，在AnnotationConfigApplicationContext的构造函数中就会调用这个方法。它是 AnnotationConfigApplicationContext的父类 AbstractApplicationContext 的一个方法 ， 顾名思义，用于刷新整个Spring 上下文信息，定义了整个 Spring 上下文加载的流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>();</span><br><span class="line">	register(componentClasses);</span><br><span class="line">	refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么牛逼的方法源码很是简洁，在refresh()基本都是调用其他方法，备注也很齐全，所以一眼看上去就知道Spring刷新上下文的整个流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">            <span class="comment">// 为刷新准备上下文</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">            <span class="comment">// 让子类去创建和初始化 BeanFactory</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">            <span class="comment">// 填充BeanFactory的功能</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">                <span class="comment">// 提供子类覆盖的额外处理，即子类自定义的BeanFactoryPostProcess</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">                <span class="comment">// 激活各种BeanFacytory处理器</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">                <span class="comment">//注册拦截Bean创建的Bean处理器，这里只是注册，真正的调用实在getBean时候，BeanPostProcessor</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">                <span class="comment">// 初始化上下文资源文件，如国际化的处理等</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">                <span class="comment">// 初始化上下文事件广播器</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">                <span class="comment">// 留给子类来初始化其它的Bean </span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">                <span class="comment">// 在所有的bean中查找listener bean，然后注册到广播器中</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">                <span class="comment">// 初始化剩下的单例bean</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">                <span class="comment">// 完成刷新过程，通知生命周期处理器lifeCycleProcessor刷新过程，同时发出ContextRefreshEvent通知别人</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">							<span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				<span class="comment">// 销毁已经创建的bean</span></span><br><span class="line">                destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset 'active' flag.</span></span><br><span class="line">                <span class="comment">// 重置容器激活标签</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">				<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单整理"><a href="#简单整理" class="headerlink" title="简单整理"></a>简单整理</h2><table>
<thead>
<tr>
<th>函数</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td>1.prepareRrefresh()</td>
<td align="left">初始化上下文环境，对系统的环境变量或系统属性进行准备和校验，如环境变量中必须设置某个值才能运行，否则就不行，这时候可以在这里加一个校验，重写initPropertySources方法就好。</td>
</tr>
<tr>
<td>2.obtainFreshBeanFactory()</td>
<td align="left">创建并初始化bean</td>
</tr>
<tr>
<td>3.prepareBeanFactory(beanFactory)</td>
<td align="left">填充BeanFactory的功能</td>
</tr>
<tr>
<td>4.postProcessBeanFactory()</td>
<td align="left">提供覆盖子类的额外处理，即子类处理自定义的BeanFactoryPostProcess</td>
</tr>
<tr>
<td>5.invokeBeanFactoryPostProcessor()</td>
<td align="left">激活各种BeanFactory处理器</td>
</tr>
<tr>
<td>6.registerBeanPostProcessors()</td>
<td align="left">注册拦截Bean创建的Bean处理器，即注册BeanPostProcessor</td>
</tr>
<tr>
<td>7.initMessageSource()</td>
<td align="left">初始化上下文中的资源文件，如国际化文件的处理等</td>
</tr>
<tr>
<td>8.initApplicationEventMulticaster()</td>
<td align="left">初始化上下文广播器</td>
</tr>
<tr>
<td>9.onRefresh()</td>
<td align="left">预留给子类拓展初始化其他Bean</td>
</tr>
<tr>
<td>10.registerListeners()</td>
<td align="left">在所有bean中查找listener bean，然后注册到广播器中</td>
</tr>
<tr>
<td>11.finishBeanFactoryInitialization(beanFactory)</td>
<td align="left">初始化剩下的单例bean(非延迟加载的)</td>
</tr>
<tr>
<td>12.finishRefresh()</td>
<td align="left">完成刷新过程，通知生命周期处理器lifecycleProcessor刷新过程，同时发出ContextRefreshEvent通知别人</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/24/applicationContext%E4%B8%AD%E7%9A%84Refresh-%E6%96%B9%E6%B3%95/" data-id="ckbtawyhq0000n8ug81arb704" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-阻塞队列存取方法区别大总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/23/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%E5%A4%A7%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-06-23T02:37:01.000Z" itemprop="datePublished">2020-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/23/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%E5%A4%A7%E6%80%BB%E7%BB%93/">阻塞队列存取方法区别大总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="BlockingQueue和Queue"><a href="#BlockingQueue和Queue" class="headerlink" title="BlockingQueue和Queue"></a>BlockingQueue和Queue</h2><p>阻塞队列（BlockingQueue）是一个接口，它继承自Queue接口，是队列的一种，不过BlockingQueue是线程安全的。</p>
<p>下面是BlockingQueue中定义的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外加上他爹Queue中定义的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="获取移除方法分类总结"><a href="#获取移除方法分类总结" class="headerlink" title="获取移除方法分类总结"></a>获取移除方法分类总结</h2><h3 id="第一组：抛异常"><a href="#第一组：抛异常" class="headerlink" title="第一组：抛异常"></a>第一组：抛异常</h3><ul>
<li><strong>add</strong>：增加一个元素，如果队列满了，抛出异常</li>
<li><strong>remove</strong>：删除一个元素，如果队列空了，抛出异常</li>
<li><strong>element</strong>：查看第一个元素，如果队列空了，抛出异常</li>
</ul>
<h3 id="第二组：返回false或null"><a href="#第二组：返回false或null" class="headerlink" title="第二组：返回false或null"></a>第二组：返回false或null</h3><ul>
<li><strong>offer</strong>：增加一个元素，如果队列满了，返回false</li>
<li><strong>poll</strong>：删除一个元素，如果队列空了，返回null，所以不允许插入null，不然就不知道这个null到底是没元素时候的返回值，还是本身插入的就是null</li>
<li><strong>peek</strong>：查看第一个元素，如果队列空了，返回null</li>
</ul>
<h4 id="带时间的方法"><a href="#带时间的方法" class="headerlink" title="带时间的方法"></a>带时间的方法</h4><p>以上第二组的方法都有带时间参数的重载方法，语义是：如果第一时间操作不成功，就等一会。过期了再返回。</p>
<h3 id="第三组：阻塞"><a href="#第三组：阻塞" class="headerlink" title="第三组：阻塞"></a>第三组：阻塞</h3><ul>
<li><strong>put</strong>：增加一个元素：如果队列满了，阻塞</li>
<li><strong>take</strong>：删除一个元素，如果队列空了，阻塞</li>
</ul>
<h3 id="注：以上的增加都是队尾增加，删除都是队头删除。也就是队列的FIFO"><a href="#注：以上的增加都是队尾增加，删除都是队头删除。也就是队列的FIFO" class="headerlink" title="注：以上的增加都是队尾增加，删除都是队头删除。也就是队列的FIFO"></a>注：以上的增加都是队尾增加，删除都是队头删除。也就是队列的FIFO</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/23/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%E5%A4%A7%E6%80%BB%E7%BB%93/" data-id="ckbrc1zcz00003sugb96cea2b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-synchronized和Lock孰优孰劣，如何选择？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/22/synchronized%E5%92%8CLock%E5%AD%B0%E4%BC%98%E5%AD%B0%E5%8A%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F/" class="article-date">
  <time datetime="2020-06-22T03:02:04.000Z" itemprop="datePublished">2020-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/22/synchronized%E5%92%8CLock%E5%AD%B0%E4%BC%98%E5%AD%B0%E5%8A%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F/">synchronized和Lock孰优孰劣，如何选择？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本节我们主要学习 synchronized 和 Lock 的异同点，以及该如何选择。</p>
<h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>synchronized 和 Lock 的相同点非常多，我们这里重点讲解 3 个比较大的相同点。</p>
<ul>
<li><strong>synchronized 和 Lock 都是用来保护资源线程安全的。</strong></li>
</ul>
<p>这一点毋庸置疑，这是它们的基本作用。</p>
<ul>
<li><strong>都可以保证可见性。</strong></li>
</ul>
<p>对于 synchronized 而言，线程 A 在进入 synchronized 块之前或在 synchronized 块内进行操作，对于后续的获得同一个 monitor 锁的线程 B 是可见的，也就是线程 B 是可以看到线程 A 之前的操作的，这也体现了 happens-before 针对 synchronized 的一个原则。</p>
<img src="/2020/06/22/synchronized%E5%92%8CLock%E5%AD%B0%E4%BC%98%E5%AD%B0%E5%8A%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F/1.png" class title="happends-before">

<p>而对于 Lock 而言，它和 synchronized 是一样，都可以保证可见性，如图所示，在解锁之前的所有操作对加锁之后的所有操作都是可见的。</p>
<img src="/2020/06/22/synchronized%E5%92%8CLock%E5%AD%B0%E4%BC%98%E5%AD%B0%E5%8A%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F/2.png" class title="happends-before">

<p>如果你之前不了解什么是可见性，此时理解可能会有一定的困难，可以在学习本专栏的 Java 内存模型相关内容后，再复习本课时，就会豁然开朗。</p>
<ul>
<li><strong>synchronized 和 ReentrantLock 都拥有可重入的特点。</strong></li>
</ul>
<p>这里的 ReentrantLock 是 Lock 接口的一个最主要的实现类，在对比 synchronized 和 Lock 的时候，也会选择 Lock 的主要实现类来进行对比。可重入指的是某个线程如果已经获得了一个锁，现在试图再次请求这个它已经获得的锁，如果它无需提前释放这个锁，而是直接可以继续使用持有的这个锁，那么就是可重入的。如果必须释放锁后才能再次申请这个锁，就是不可重入的。而 synchronized 和 ReentrantLock 都具有可重入的特性。</p>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>下面我们来看下 synchronized 和 Lock 的区别，和相同点一样，它们之间也有非常多的区别，这里讲解其中比较大的 7 点不同。</p>
<ul>
<li><strong>用法区别</strong></li>
</ul>
<p>synchronized 关键字可以加在方法上，不需要指定锁对象（此时的锁对象为 this），也可以新建一个同步代码块并且自定义 monitor 锁对象；而 Lock 接口必须显示用 Lock 锁对象开始加锁 lock() 和解锁 unlock()，并且一般会在 finally 块中确保用 unlock() 来解锁，以防发生死锁。</p>
<p>与 Lock 显式的加锁和解锁不同的是 synchronized 的加解锁是隐式的，尤其是抛异常的时候也能保证释放锁，但是 Java 代码中并没有相关的体现。</p>
<ul>
<li><strong>加解锁顺序不同</strong></li>
</ul>
<p>对于 Lock 而言如果有多把 Lock 锁，Lock 可以不完全按照加锁的反序解锁，比如我们可以先获取 Lock1 锁，再获取 Lock2 锁，解锁时则先解锁 Lock1，再解锁 Lock2，加解锁有一定的灵活度，如代码所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock1.lock();</span><br><span class="line">lock2.lock();</span><br><span class="line">...</span><br><span class="line">lock1.unlock();</span><br><span class="line">lock2.unlock();</span><br></pre></td></tr></table></figure>

<p>但是 synchronized 无法做到，synchronized 解锁的顺序和加锁的顺序必须完全相反，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj1)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj2)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在这里，顺序就是先对 obj1 加锁，然后对 obj2 加锁，然后对 obj2 解锁，最后解锁 obj1。这是因为 synchronized 加解锁是由 JVM 实现的，在执行完 synchronized 块后会自动解锁，所以会按照 synchronized 的嵌套顺序加解锁，不能自行控制。</p>
<ul>
<li><strong>synchronized 锁不够灵活</strong></li>
</ul>
<p>一旦 synchronized 锁已经被某个线程获得了，此时其他线程如果还想获得，那它只能被阻塞，直到持有锁的线程运行完毕或者发生异常从而释放这个锁。如果持有锁的线程持有很长时间才释放，那么整个程序的运行效率就会降低，而且如果持有锁的线程永远不释放锁，那么尝试获取锁的线程只能永远等下去。</p>
<p>相比之下，Lock 类在等锁的过程中，如果使用的是 lockInterruptibly 方法，那么如果觉得等待的时间太长了不想再继续等待，可以中断退出，也可以用 tryLock() 等方法尝试获取锁，如果获取不到锁也可以做别的事，更加灵活。</p>
<ul>
<li><strong>synchronized 锁只能同时被一个线程拥有，但是 Lock 锁没有这个限制</strong></li>
</ul>
<p>例如在读写锁中的读锁，是可以同时被多个线程持有的，可是 synchronized 做不到。</p>
<ul>
<li><strong>原理区别</strong></li>
</ul>
<p>synchronized 是内置锁，由 JVM 实现获取锁和释放锁的原理，还分为偏向锁、轻量级锁、重量级锁。</p>
<p>Lock 根据实现不同，有不同的原理，例如 ReentrantLock 内部是通过 AQS 来获取和释放锁的。</p>
<ul>
<li><strong>是否可以设置公平/非公平</strong></li>
</ul>
<p>公平锁是指多个线程在等待同一个锁时，根据先来后到的原则依次获得锁。ReentrantLock 等 Lock 实现类可以根据自己的需要来设置公平或非公平，synchronized 则不能设置。</p>
<ul>
<li><strong>性能区别</strong></li>
</ul>
<p>在 Java 5 以及之前，synchronized 的性能比较低，但是到了 Java 6 以后，发生了变化，因为 JDK 对 synchronized 进行了很多优化，比如自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等，所以后期的 Java 版本里的 synchronized 的性能并不比 Lock 差。</p>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>讲完了 synchronized 和 Lock 的相同点和区别，最后我们再来看下如何选择它们，在 Java 并发编程实战和 Java 核心技术里都认为：</p>
<ol>
<li>如果能不用最好既不使用 Lock 也不使用 synchronized。因为在许多情况下你可以使用 java.util.concurrent 包中的机制，它会为你处理所有的加锁和解锁操作，也就是推荐优先使用工具类来加解锁。</li>
<li>如果 synchronized 关键字适合你的程序， 那么请尽量使用它，这样可以减少编写代码的数量，减少出错的概率。因为一旦忘记在 finally 里 unlock，代码可能会出很大的问题，而使用 synchronized 更安全。</li>
<li>如果特别需要 Lock 的特殊功能，比如尝试获取锁、可中断、超时功能等，才使用 Lock。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/22/synchronized%E5%92%8CLock%E5%AD%B0%E4%BC%98%E5%AD%B0%E5%8A%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F/" data-id="ckbpx8rmo0000agug4mri9ex5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-如何正确停止线程？为什么用volatile标记位的方法是错误的？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/19/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8volatile%E6%A0%87%E8%AE%B0%E4%BD%8D%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%9F/" class="article-date">
  <time datetime="2020-06-19T08:31:21.000Z" itemprop="datePublished">2020-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/19/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8volatile%E6%A0%87%E8%AE%B0%E4%BD%8D%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%9F/">如何正确停止线程？为什么用volatile标记位的方法是错误的？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在本课时我们主要学习如何正确停止一个线程？以及为什么用 volatile 标记位的停止方法是错误的？</p>
<p>首先，我们来复习如何启动一个线程，想要启动线程需要调用 Thread 类的 start() 方法，并在 run() 方法中定义需要执行的任务。启动一个线程非常简单，但如果想要正确停止它就没那么容易了。</p>
<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><p>通常情况下，我们不会手动停止一个线程，而是允许线程运行到结束，然后让它自然停止。但是依然会有许多特殊的情况需要我们提前停止线程，比如：用户突然关闭程序，或程序运行出错重启等。</p>
<p>在这种情况下，即将停止的线程在很多业务场景下仍然很有价值。尤其是我们想写一个健壮性很好，能够安全应对各种场景的程序时，正确停止线程就显得格外重要。但是Java 并没有提供简单易用，能够直接安全停止线程的能力。</p>
<h3 id="为什么不强制停止？而是通知、协作"><a href="#为什么不强制停止？而是通知、协作" class="headerlink" title="为什么不强制停止？而是通知、协作"></a>为什么不强制停止？而是通知、协作</h3><p>对于 Java 而言，最正确的停止线程的方式是使用 interrupt。但 interrupt 仅仅起到通知被停止线程的作用。而对于被停止的线程而言，它拥有完全的自主权，它既可以选择立即停止，也可以选择一段时间后停止，也可以选择压根不停止。那么为什么 Java 不提供强制停止线程的能力呢？</p>
<p>事实上，Java 希望程序间能够相互通知、相互协作地管理线程，因为如果不了解对方正在做的工作，贸然强制停止线程就可能会造成一些安全的问题，为了避免造成问题就需要给对方一定的时间来整理收尾工作。比如：线程正在写入一个文件，这时收到终止信号，它就需要根据自身业务判断，是选择立即停止，还是将整个文件写入成功后停止，而如果选择立即停止就可能造成数据不完整，不管是中断命令发起者，还是接收者都不希望数据出现问题。</p>
<h3 id="如何用-interrupt-停止线程"><a href="#如何用-interrupt-停止线程" class="headerlink" title="如何用 interrupt 停止线程"></a>如何用 interrupt 停止线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.currentThread().islnterrupted() &amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> more work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明白 Java 停止线程的设计原则之后，我们看看如何用代码实现停止线程的逻辑。我们一旦调用某个线程的 interrupt() 之后，这个线程的中断标记位就会被设置成 true。每个线程都有这样的标记位，当线程执行时，应该定期检查这个标记位，如果标记位被设置成 true，就说明有程序想终止该线程。回到源码，可以看到在 while 循环体判断语句中，首先通过 Thread.currentThread().isInterrupt() 判断线程是否被中断，随后检查是否还有工作要做。&amp;&amp; 逻辑表示只有当两个判断条件同时满足的情况下，才会去执行下面的工作。</p>
<p>我们再看看具体例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; count &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"count = "</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> StopThread());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 StopThread 类的 run() 方法中，首先判断线程是否被中断，然后判断 count 值是否小于 1000。这个线程的工作内容很简单，就是打印 0~999 的数字，每打印一个数字 count 值加 1，可以看到，线程会在每次循环开始之前，检查是否被中断了。接下来在 main 函数中会启动该线程，然后休眠 5 毫秒后立刻中断线程，该线程会检测到中断信号，于是在还没打印完1000个数的时候就会停下来，这种就属于通过 interrupt 正确停止线程的情况。</p>
<h3 id="sleep-期间能否感受到中断"><a href="#sleep-期间能否感受到中断" class="headerlink" title="sleep 期间能否感受到中断"></a>sleep 期间能否感受到中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; </span><br><span class="line">        num &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">            num++;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么我们考虑一种特殊情况，改写上面的代码，如果线程在执行任务期间有休眠需求，也就是每打印一个数字，就进入一次 sleep ，而此时将 Thread.sleep() 的休眠时间设置为 1000 秒钟。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopDuringSleep</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; num &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">                    System.out.println(num);</span><br><span class="line">                    num++;</span><br><span class="line">                    Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程休眠 5 毫秒后，通知子线程中断，此时子线程仍在执行 sleep 语句，处于休眠中。那么就需要考虑一点，在休眠中的线程是否能够感受到中断通知呢？是否需要等到休眠结束后才能中断线程呢？如果是这样，就会带来严重的问题，因为响应中断太不及时了。正因为如此，Java 设计者在设计之初就考虑到了这一点。</p>
<p>如果 sleep、wait 等可以让线程进入阻塞的方法使线程休眠了，而处于休眠中的线程被中断，那么线程是可以感受到中断信号的，并且会抛出一个 InterruptedException 异常，同时清除中断信号，将中断标记位设置成 false。这样一来就不用担心长时间休眠中线程感受不到中断了，因为即便线程还在休眠，仍然能够响应中断通知，并抛出异常。</p>
<h2 id="两种最佳处理方式"><a href="#两种最佳处理方式" class="headerlink" title="两种最佳处理方式"></a>两种最佳处理方式</h2><p>在实际开发中肯定是团队协作的，不同的人负责编写不同的方法，然后相互调用来实现整个业务的逻辑。那么如果我们负责编写的方法需要被别人调用，同时我们的方法内调用了 sleep 或者 wait 等能响应中断的方法时，仅仅 catch 住异常是不够的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subTas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// 在这里不处理该异常是非常不好的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在方法中使用 try/catch 或在方法签名中声明 throws  InterruptedException。</p>
<h3 id="方法签名抛异常，run-强制-try-catch"><a href="#方法签名抛异常，run-强制-try-catch" class="headerlink" title="方法签名抛异常，run() 强制 try/catch"></a>方法签名抛异常，run() 强制 try/catch</h3><p>我们先来看下 try/catch 的处理逻辑。如上面的代码所示，catch 语句块里代码是空的，它并没有进行任何处理。假设线程执行到这个方法，并且正在 sleep，此时有线程发送 interrupt 通知试图中断线程，就会立即抛出异常，并清除中断信号。抛出的异常被 catch 语句块捕捉。</p>
<p>但是，捕捉到异常的 catch 没有进行任何处理逻辑，相当于把中断信号给隐藏了，这样做是非常不合理的，那么究竟应该怎么处理呢？首先，可以选择在方法签名中抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subTask2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如代码所示，要求每一个方法的调用方有义务去处理异常。调用方要不使用 try/catch 并在 catch 中正确处理异常，要不将异常声明到方法签名中。如果每层逻辑都遵守规范，便可以将中断信号层层传递到顶层，最终让 run() 方法可以捕获到异常。而对于 run() 方法而言，它本身没有抛出 checkedException 的能力，只能通过 try/catch 来处理异常。层层传递异常的逻辑保障了异常不会被遗漏，而对 run() 方法而言，就可以根据不同的业务逻辑来进行相应的处理。</p>
<h3 id="再次中断"><a href="#再次中断" class="headerlink" title="再次中断"></a>再次中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了刚才推荐的将异常声明到方法签名中的方式外，还可以在 catch 语句中再次中断线程。如代码所示，需要在 catch 语句块中调用 Thread.currentThread().interrupt() 函数。因为如果线程在休眠期间被中断，那么会自动清除中断信号。如果这时手动添加中断信号，中断信号依然可以被捕捉到。这样后续执行的方法依然可以检测到这里发生过中断，可以做出相应的处理，整个线程可以正常退出。</p>
<p>我们需要注意，我们在实际开发中不能盲目吞掉中断，如果不在方法签名中声明，也不在 catch 语句块中再次恢复中断，而是在 catch 中不作处理，我们称这种行为是“屏蔽了中断请求”。如果我们盲目地屏蔽了中断请求，会导致中断信号被完全忽略，最终导致线程无法正确停止。</p>
<h2 id="为什么用-volatile-标记位的停止方法是错误的"><a href="#为什么用-volatile-标记位的停止方法是错误的" class="headerlink" title="为什么用 volatile 标记位的停止方法是错误的"></a>为什么用 volatile 标记位的停止方法是错误的</h2><p>下面我们来看一看本课时的第二个问题，为什么用 volatile 标记位的停止方法是错误的？</p>
<h3 id="错误的停止方法"><a href="#错误的停止方法" class="headerlink" title="错误的停止方法"></a>错误的停止方法</h3><p>首先，我们来看几种停止线程的错误方法。比如 stop()，suspend() 和 resume()，这些方法已经被 Java 直接标记为 @Deprecated。如果再调用这些方法，IDE 会友好地提示，我们不应该再使用它们了。但为什么它们不能使用了呢？是因为 stop() 会直接把线程停止，这样就没有给线程足够的时间来处理想要在停止前保存数据的逻辑，任务戛然而止，会导致出现数据完整性等问题。</p>
<p>而对于 suspend() 和 resume() 而言，它们的问题在于如果线程调用 suspend()，它并不会释放锁，就开始进入休眠，但此时有可能仍持有锁，这样就容易导致死锁问题，因为这把锁在线程被 resume() 之前，是不会被释放的。</p>
<p>假设线程 A 调用了 suspend() 方法让线程 B 挂起，线程 B 进入休眠，而线程 B 又刚好持有一把锁，此时假设线程 A 想访问线程 B 持有的锁，但线程 B 并没有释放锁就进入休眠等待唤醒，而对于线程 A 而言，又不会唤醒线程 B，除非拿到锁，这就造成了死锁问题。</p>
<p>正是因为有这样的风险，所以 suspend() 和 resume() 组合使用的方法也被废弃了。那么接下来我们来看看，为什么用 volatile 标记位的停止方法也是错误的？</p>
<h3 id="volatile-修饰标记位适用的场景"><a href="#volatile-修饰标记位适用的场景" class="headerlink" title="volatile 修饰标记位适用的场景"></a>volatile 修饰标记位适用的场景</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCanStop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!canceled &amp;&amp; num &lt;= <span class="number">1000000</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(num + <span class="string">"是10的倍数。"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        VolatileCanStop r = <span class="keyword">new</span> VolatileCanStop();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        r.canceled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么场景下 volatile 修饰标记位可以让线程正常停止呢？如代码所示，声明了一个叫作 VolatileStopThread 的类， 它实现了 Runnable 接口，然后在 run() 中进行 while 循环，在循环体中又进行了两层判断，首先判断 canceled 变量的值，canceled 变量是一个被 volatile 修饰的初始值为 false 的布尔值，当该值变为 true 时，while 跳出循环，while 的第二个判断条件是 num 值小于1000000（一百万），在while 循环体里，只要是 10 的倍数就打印出来，然后 num++。</p>
<p>接下来，首先启动线程，然后经过 3 秒钟的时间，把用 volatile 修饰的布尔值的标记位设置成 true，这样，正在运行的线程就会在下一次 while 循环中判断出 canceled 的值已经变成 true 了，这样就不再满足 while 的判断条件，跳出整个 while 循环，线程就停止了，这种情况是演示 volatile 修饰的标记位可以正常工作的情况，但是如果我们说某个方法是正确的，那么它应该不仅仅是在一种情况下适用，而在其他情况下也应该是适用的。</p>
<h3 id="volatile-修饰标记位不适用的场景"><a href="#volatile-修饰标记位不适用的场景" class="headerlink" title="volatile 修饰标记位不适用的场景"></a>volatile 修饰标记位不适用的场景</h3><p>接下来我们就用一个生产者/消费者模式的案例来演示为什么说  volatile 标记位的停止方法是不完美的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line">    BlockingQueue storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">100000</span> &amp;&amp; !canceled) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">50</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    storage.put(num);</span><br><span class="line">                    System.out.println(num + <span class="string">"是50的倍数,被放到仓库中了。"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"生产者结束运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，声明了一个生产者 Producer，通过 volatile 标记的初始值为 false 的布尔值 canceled 来停止线程。而在 run() 方法中，while 的判断语句是 num 是否小于 100000 及 canceled 是否被标记。while 循环体中判断 num 如果是 50 的倍数就放到 storage 仓库中，storage 是生产者与消费者之间进行通信的存储器，当 num 大于 100000 或被通知停止时，会跳出 while 循环并执行 finally 语句块，告诉大家“生产者结束运行”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    BlockingQueue storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.97</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于消费者 Consumer，它与生产者共用同一个仓库 storage，并且在方法内通过 needMoreNums() 方法判断是否需要继续使用更多的数字，刚才生产者生产了一些 50 的倍数供消费者使用，消费者是否继续使用数字的判断条件是产生一个随机数并与 0.97 进行比较，大于 0.97 就不再继续使用数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayBlockingQueue storage = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        producerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(storage);</span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums()) &#123;</span><br><span class="line">            System.out.println(consumer.storage.take() + <span class="string">"被消费了"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"消费者不需要更多数据了。"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一旦消费不需要更多数据了，我们应该让生产者也停下来，但是实际情况却停不下来</span></span><br><span class="line">        producer.canceled = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(producer.canceled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看下 main 函数，首先创建了生产者/消费者共用的仓库 BlockingQueue storage，仓库容量是 8，并且建立生产者并将生产者放入线程后启动线程，启动后进行 500 毫秒的休眠，休眠时间保障生产者有足够的时间把仓库塞满，而仓库达到容量后就不会再继续往里塞，这时生产者会阻塞，500 毫秒后消费者也被创建出来，并判断是否需要使用更多的数字，然后每次消费后休眠 100 毫秒，这样的业务逻辑是有可能出现在实际生产中的。</p>
<p>当消费者不再需要数据，就会将 canceled 的标记位设置为 true，理论上此时生产者会跳出 while 循环，并打印输出“生产者运行结束”。</p>
<p>然而结果却不是我们想象的那样，尽管已经把 canceled 设置成 true，但生产者仍然没有停止，这是因为在这种情况下，生产者在执行 storage.put(num) 时发生阻塞，在它被叫醒之前是没有办法进入下一次循环判断 canceled 的值的，所以在这种情况下用 volatile 是没有办法让生产者停下来的，相反如果用 interrupt 语句来中断，即使生产者处于阻塞状态，仍然能够感受到中断信号，并做响应处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，本课时的内容就全部讲完了，我们来总结下学到了什么，首先学习了如何正确停止线程，其次是掌握了为什么说 volatile 修饰标记位停止方法是错误的。</p>
<p>如果我们在面试中被问到“你知不知道如何正确停止线程”这样的问题，我想你一定可以完美地回答了，首先，从原理上讲应该用 interrupt 来请求中断，而不是强制停止，因为这样可以避免数据错乱，也可以让线程有时间结束收尾工作。</p>
<p>如果我们是子方法的编写者，遇到了 interruptedException，应该如何处理呢？</p>
<p>我们可以把异常声明在方法中，以便顶层方法可以感知捕获到异常，或者也可以在 catch 中再次声明中断，这样下次循环也可以感知中断，所以要想正确停止线程就要求我们停止方，被停止方，子方法的编写者相互配合，大家都按照一定的规范来编写代码，就可以正确地停止线程了。</p>
<p>最后我们再来看下有哪些方法是不够好的，比如说已经被舍弃的 stop()、suspend() 和 resume()，它们由于有很大的安全风险比如死锁风险而被舍弃，而 volatile 这种方法在某些特殊的情况下，比如线程被长时间阻塞的情况，就无法及时感受中断，所以 volatile 是不够全面的停止线程的方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/19/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8volatile%E6%A0%87%E8%AE%B0%E4%BD%8D%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%9F/" data-id="ckblyqx9n0000lcug80n05x3s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-为什么说只有一种实现线程的方式？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F/" class="article-date">
  <time datetime="2020-06-19T06:26:33.000Z" itemprop="datePublished">2020-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F/">为什么说只有一种实现线程的方式？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>实现线程是并发编程中基础中的基础，因为我们必须要先实现多线程，才可以继续后续的一系列操作。所以本课时就先从并发编程的基础如何实现线程开始讲起，希望你能够夯实基础，虽然实现线程看似简单、基础，但实际上却暗藏玄机。首先，我们来看下为什么说本质上实现线程只有一种方式？</p>
<p>实现线程的方式到底有几种？大部分人会说有 2 种、3 种或是 4 种，很少有人会说有 1 种。我们接下来看看它们具体指什么？2 种实现方式的描述是最基本的，也是最为大家熟知的，我们就先来看看 2 种线程实现方式的源码。</p>
<p><strong>实现 Runnable 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">'用实现Runnable接口实现线程'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 1 种方式是通过实现 Runnable 接口实现多线程，如代码所示，首先通过 RunnableThread 类实现 Runnable 接口，然后重写 run() 方法，之后只需要把这个实现了 run() 方法的实例传到 Thread 类中就可以实现多线程。</p>
<p><strong>继承 Thread 类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">'用Thread类实现线程'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 2 种方式是继承 Thread 类，如代码所示，与第 1 种方式不同的是它没有实现接口，而是继承 Thread 类，并重写了其中的 run() 方法。相信上面这两种方式你一定非常熟悉，并且经常在工作中使用它们。</p>
<p><strong>线程池创建线程</strong></p>
<p>那么为什么说还有第 3 种或第 4 种方式呢？我们先来看看第 3 种方式：通过线程池创建线程。线程池确实实现了多线程，比如我们给线程池的线程数量设置成 10，那么就会有 10 个子线程来为我们工作，接下来，我们深入解析线程池中的源码，来看看线程池是怎么实现线程的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">            Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">            poolNumber.getAndIncrement() +</span><br><span class="line">            <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                    namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line"><span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于线程池而言，本质上是通过线程工厂创建线程的，默认采用 DefaultThreadFactory ，它会给线程池创建的线程设置一些默认值，比如：线程的名字、是否是守护线程，以及线程的优先级等。但是无论怎么设置这些属性，最终它还是通过 new Thread() 创建线程的 ，只不过这里的构造函数传入的参数要多一些，由此可以看出通过线程池创建线程并没有脱离最开始的那两种基本的创建方式，因为本质上还是通过 new Thread() 实现的。</p>
<p>在面试中，如果你只是知道这种方式可以创建线程但不了解其背后的实现原理，就会在面试的过程中举步维艰，想更好的表现自己却给自己挖了“坑”。</p>
<p>所以我们在回答线程实现的问题时，描述完前两种方式，可以进一步引申说“我还知道线程池和Callable 也是可以创建线程的，但是它们本质上也是通过前两种基本方式实现的线程创建。”这样的回答会成为面试中的加分项。然后面试官大概率会追问线程池的构成及原理，这部分内容会在后面的课时中详细分析。</p>
<p><strong>有返回值的 Callable 创建线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//提交任务，并用 Future提交返回结果</span></span><br><span class="line">Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> CallableTask());</span><br></pre></td></tr></table></figure>

<p>第 4 种线程创建方式是通过有返回值的 Callable 创建线程，Runnable 创建线程是无返回值的，而 Callable 和与之相关的 Future、FutureTask，它们可以把线程执行的结果作为返回值返回，如代码所示，实现了 Callable 接口，并且给它的泛型设置成 Integer，然后它会返回一个随机数。</p>
<p>但是，无论是 Callable 还是 FutureTask，它们首先和 Runnable 一样，都是一个任务，是需要被执行的，而不是说它们本身就是线程。它们可以放到线程池中执行，如代码所示， submit() 方法把任务放到线程池中，并由线程池创建线程，不管用什么方法，最终都是靠线程来执行的，而子线程的创建方式仍脱离不了最开始讲的两种基本方式，也就是实现 Runnable 接口和继承 Thread 类。</p>
<p><strong>其他创建方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="comment">//具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲到这里你可能会说，我还知道一些其他的实现线程的方式。比如，定时器也可以实现线程，如果新建一个 Timer，令其每隔 10 秒或设置两个小时之后，执行一些任务，那么这时它确实也创建了线程并执行了任务，但如果我们深入分析定时器的源码会发现，本质上它还是会有一个继承自 Thread 类的 TimerThread，所以定时器创建线程最后又绕回到最开始说的两种方式。</p>
<p><strong>其他方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>或许你还会说，我还知道一些其他方式，比如匿名内部类或 lambda 表达式方式，实际上，匿名内部类或 lambda 表达式创建线程，它们仅仅是在语法层面上实现了线程，并不能把它归结于实现多线程的方式，如匿名内部类实现线程的代码所示，它仅仅是用一个匿名内部类把需要传入的 Runnable 给实例出来。</p>
<p>我们再来看下 lambda 表达式方式。如代码所示，最终它们依然符合最开始所说的那两种实现线程的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(Thread.currentThread().getName())).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现线程只有一种方式</strong></p>
<p>关于这个问题，我们先不聚焦为什么说创建线程只有一种方式，先认为有两种创建线程的方式，而其他的创建方式，比如线程池或是定时器，它们仅仅是在 new Thread() 外做了一层封装，如果我们把这些都叫作一种新的方式，那么创建线程的方式便会千变万化、层出不穷，比如 JDK 更新了，它可能会多出几个类，会把 new Thread() 重新封装，表面上看又会是一种新的实现线程的方式，透过现象看本质，打开封装后，会发现它们最终都是基于 Runnable 接口或继承 Thread 类实现的。</p>
<p>接下来，我们进行更深层次的探讨，为什么说这两种方式本质上是一种呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，启动线程需要调用 start() 方法，而 start() 方法最终还会调用 run() 方法，我们先来看看第一种方式中 run() 方法究竟是怎么实现的，可以看出 run() 方法的代码非常短小精悍，第 1 行代码 if (target != null) ，判断 target 是否等于 null，如果不等于 null，就执行第 2 行代码 target.run()，而 target 实际上就是一个 Runnable，即使用 Runnable 接口实现线程时传给Thread类的对象。</p>
<p>然后，我们来看第二种方式，也就是继承 Thread 方式，实际上，继承 Thread 类之后，会把上述的 run() 方法重写，重写后 run() 方法里直接就是所需要执行的任务，但它最终还是需要调用 thread.start() 方法来启动线程，而 start() 方法最终也会调用这个已经被重写的 run() 方法来执行它的任务，这时我们就可以彻底明白了，<strong>事实上创建线程只有一种方式，就是构造一个 Thread 类，这是创建线程的唯一方式。</strong></p>
<p>我们上面已经了解了两种创建线程方式本质上是一样的，<strong>它们的不同点仅仅在于实现线程运行内容的不同</strong>，那么运行内容来自于哪里呢？</p>
<p>运行内容主要来自于两个地方，要么来自于 target，要么来自于重写的 run() 方法，在此基础上我们进行拓展，可以这样描述：本质上，实现线程只有一种方式，而要想实现线程执行的内容，却有两种方式，也就是可以通过 实现 Runnable 接口的方式，或是继承 Thread 类重写 run() 方法的方式，把我们想要执行的代码传入，让线程去执行，在此基础上，如果我们还想有更多实现线程的方式，比如线程池和 Timer 定时器，只需要在此基础上进行封装即可。</p>
<p><strong>实现 Runnable 接口比继承 Thread 类实现线程要好</strong></p>
<p>下面我们来对刚才说的两种实现线程内容的方式进行对比，也就是为什么说实现 Runnable 接口比继承 Thread 类实现线程要好？好在哪里呢？</p>
<p>首先，我们从代码的架构考虑，实际上，Runnable 里只有一个 run() 方法，它定义了需要执行的内容，在这种情况下，实现了 Runnable 与 Thread 类的解耦，Thread 类负责线程启动和属性设置等内容，权责分明。</p>
<p>第二点就是在某些情况下可以提高性能，使用继承 Thread 类方式，每次执行一次任务，都需要新建一个独立的线程，执行完任务后线程走到生命周期的尽头被销毁，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类，如果此时执行的内容比较少，比如只是在 run() 方法里简单打印一行文字，那么它所带来的开销并不大，相比于整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。如果我们使用实现 Runnable 接口的方式，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。</p>
<p>第三点好处在于 Java 语言不支持双继承，如果我们的类一旦继承了 Thread 类，那么它后续就没有办法再继承其他的类，这样一来，如果未来这个类需要继承其他类实现一些功能上的拓展，它就没有办法做到了，相当于限制了代码未来的可拓展性。</p>
<p>综上所述，我们应该优先选择通过实现 Runnable 接口的方式来创建线程。</p>
<p>好啦，本课时的全部内容就讲完了，在这一课时我们主要学习了 通过 Runnable 接口和继承 Thread 类等几种方式创建线程，又详细分析了为什么说本质上只有一种实现线程的方式，以及实现 Runnable 接口究竟比继承 Thread 类实现线程好在哪里？学习完本课时相信你一定对创建线程有了更深入的理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F/" data-id="ckblyceql0000vsug4dk46f89" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-b-treeContains" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/17/b-treeContains/" class="article-date">
  <time datetime="2020-06-17T09:29:11.000Z" itemprop="datePublished">2020-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/b-treeContains/">mysql中3层的B+树能存多少条数据？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>InnoDB一棵B+树可以存放多少行数据？</code>这个问题的简单回答是：<code>约2千万</code>。为什么是这么多呢？因为这是可以算出来的，要搞清楚这个问题，我们先从InnoDB索引数据结构、数据组织方式说起。</p>
<p>在计算机中<code>磁盘</code>存储数据最小单元是<code>扇区</code>，一个扇区的大小是<code>512字节</code>，而<code>文件系统</code>（例如XFS/EXT4）他的最小单元是<code>块</code>，一个块的大小是<code>4k</code>，而对于我们的<code>InnoDB存储引擎</code>也有自己的最小储存单元——<code>页（Page）</code>，一个页的大小是<code>16K</code>。</p>
<p><strong>下面几张图可以帮你理解最小存储单元：</strong><br>文件系统中一个文件大小<code>只有1个字节</code>，但<code>不得不占磁盘上4KB的空间</code>。</p>
<img src="/2020/06/17/b-treeContains/pic1.png" class title="ss">

<p>innodb的所有数据文件（后缀为ibd的文件），他的大小始终都是<code>16384（16k）</code>的整数倍。<br>磁盘扇区、文件系统、InnoDB存储引擎都有各自的最小存储单元。在MySQL中我们的InnoDB页的大小默认是16k，<code>当然也可以通过参数设置</code>。</p>
<img src="/2020/06/17/b-treeContains/pic2.png" class title="ss">

<p>数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？<code>假设一行数据的大小是1k</code>，那么<code>一个页可以存放16行这样的数据</code>。</p>
<p>如果数据库只按这样的方式存储，那么如何查找数据就成为一个问题，因为我们不知道要查找的数据存在哪个页中，也不可能把所有的页遍历一遍，那样太慢了。所以人们想了一个办法，<code>用B+树的方式组织这些数据</code>。如图所示：</p>
<img src="/2020/06/17/b-treeContains/pic3.png" class title="ss">

<p>据记录按主键进行排序，分别存放在不同的页中（为了便于理解我们这里一个页中只存放3条记录，实际情况可以存放很多），除了存放<code>数据</code>的页以外，还有存放<code>键值+指针</code>的页，如图中<code>page number=3的页</code>，该页存放键值和指向数据页的指针，这样的页由N个键值+指针组成。当然它也是<code>排好序的</code>。这样的数据组织形式，我们称为索引组织表。现在来看下，要查找一条数据，怎么查？</p>
<p>比如执行如下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这里id是主键,我们通过这棵B+树来查找，首先找到根页，你怎么知道user表的根页在哪呢？其实每张表的根页位置在表空间文件中是固定的，即page number=3的页（这点我们下文还会进一步证明），找到根页后，通过<code>二分查找法</code>，定位到id=5的数据应该在指针P5指向的页中，那么进一步去page number=5的页中查找，同<code>样通过二分查询法</code>即可找到id=5的记录。</p>
<p><strong>现在我们清楚了InnoDB中主键索引B+树是如何组织数据、查询数据的，我们<code>总结一下</code>：</strong></p>
<p>1、InnoDB存储引擎的<code>最小存储单元是页</code>，页可以用于存放<code>数据</code>也可以用于存放<code>键值+指针</code>，在B+树中叶子节点存放数据，非叶子节点存放键值+指针。</p>
<p>2、索引组织表通过非叶子节点的<code>二分查找法</code>以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据；</p>
<p><strong>那么回到我们开始的问题，<code>通常一棵B+树可以存放多少行数据？</code></strong></p>
<p>这里我们<code>先假设B+树高为2</code>，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。</p>
<p>上文我们已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，<code>实际上</code>现在很多互联网业务<code>数据记录大小通常就是1K左右</code>）。</p>
<p>那么现在我们需要计算出<code>非叶子节点能存放多少指针</code>，其实这也很好算，我们假设<code>主键ID为bigint类型，长度为8字节</code>，而<code>指针大小</code>在InnoDB源码中设置为<code>6字节</code>，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即<code>16384/14=1170</code>。那么可以算出一棵<code>高度为2的B+树</code>，能存放<code>1170*16=18720条</code>这样的数据记录。</p>
<p>根据同样的原理我们可以算出一个<code>高度为3的B+树</code>可以存放：<code>1170*1170*16=21902400条</code>这样的记录。所以在InnoDB中<code>B+树高度一般为1-3层</code>，它就能<code>满足千万级的数据存储</code>。在查找数据时 <strong><code>一次页的查找代表一次IO</code></strong>， 所以通过主键索引查询通常 <strong><code>只需要1-3次IO操作</code></strong> 即可查找到数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/17/b-treeContains/" data-id="ckbj5svic0000jsug3sdq0opn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ConcurrentHashMap和HashTable" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/12/ConcurrentHashMap%E5%92%8CHashTable/" class="article-date">
  <time datetime="2020-06-12T09:15:28.000Z" itemprop="datePublished">2020-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/12/ConcurrentHashMap%E5%92%8CHashTable/">ConcurrentHashMap和HashTable</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/12/ConcurrentHashMap%E5%92%8CHashTable/" data-id="ckbj50tcc0000ocug1qqm07fi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Mybatis核心组件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/10/Mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/" class="article-date">
  <time datetime="2020-06-10T06:06:40.000Z" itemprop="datePublished">2020-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/10/Mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/">Mybatis核心组件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mybatis操作数据"><a href="#Mybatis操作数据" class="headerlink" title="Mybatis操作数据"></a>Mybatis操作数据</h2><p>下面一段使用Mybatis操作数据库的常见代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testMybatis</span> <span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取配置文件输入流</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">        <span class="comment">// 通过SqlSessionFactoryBuilder的build()方法创建SqlSessionFactory实例</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        <span class="comment">// 调用openSession()方法创建SqlSession实例</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 获取UserMapper代理对象</span></span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 执行Mapper方法，获取执行结果</span></span><br><span class="line">        List&lt;UserEntity&gt; userList = userMapper.listAllUser();</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 兼容Ibatis，通过Mapper Id执行SQL操作</span></span><br><span class="line"><span class="comment">        List&lt;UserEntity&gt; userList = sqlSession.selectList(</span></span><br><span class="line"><span class="comment">                "com.blog4java.mybatis.com.blog4java.mybatis.example.mapper.UserMapper.listAllUser");</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(JSON.toJSONString(userList));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如上面的代码所示，<code>SqlSession</code>是<code>MyBatis</code>中提供与数据库交互的接口，<code>SqlSession</code>实例通过工厂模式创建。为了创建<code>SqlSession</code>对象，首先需要创建<code>SqlSessionFactory</code>对象，而<code>SqlSessionFactory</code>对象的创建依赖于<code>SqlSessionFactoryBuilder</code>类，该类提供了一系列重载的<code>build()</code>方法，我们需要以主配置文件的输入流作为参数调用<code>SqlSessionFactoryBuilder</code>的<code>build()</code>方法，以获取一个<code>SqlSessionFactory</code>对象。调用<code>SqlSessionFactory</code>对象的<code>openSession()</code>获取一个与数据库建立连接的<code>SqlSession</code>实例。然后调用<code>getMapper()</code>方法获取一个动态代理对象，然后通过代理实例的方法，完成与数据库的交互。</p>
<h2 id="Mybatis核心组件"><a href="#Mybatis核心组件" class="headerlink" title="Mybatis核心组件"></a>Mybatis核心组件</h2><p>上面接触Mybatis比较核心的一个组件<code>SqlSession</code>，它是Mybatis提供给用户操作数据库的API，那么MyBatis底层又是如何工作的呢？我准备了一张图，这里画出了Mybatis中一些比较核心的组件。</p>
<img src="/2020/06/10/Mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png" class title="核心组件">

<p>下面简单介绍这些核心组件：</p>
<ul>
<li><strong>Configuration</strong>：用户描述Mybatis的主配置信息，其他组件需要获取配置信息时，直接通过Configuration对象获取。除此以外，MyBatis在应用启动时，将Mapper配置信息，类型别名，TypeHandler等注册到Configuration组件中，其他组件需要的时候可以获取。</li>
<li><strong>MappedStatement</strong>：MappedStatement用于描述Mapper中的Sql配置信息，是对Mapper XML配置文件中&lt;select|update|delete|insert&gt;等标签或者@Select/@Update等注解配置信息的封装。</li>
<li><strong>SqlSession</strong>:SqlSession是MyBatis提供的面向用户API，表示和数据库交互式的会话对象，用于完成数据库的增删改查功能。SqlSession是Executor组件的外观，目的是对外提供易于理解和使用的数据库操作接口。</li>
<li><strong>Executor</strong>：Executor是MyBatis的Sql执行器，MyBatis中对数据库所有的增删改查操作都是由Executor组件完成的。</li>
<li><strong>StatementHandler</strong>：StatementHandler封装了对JDBC Statement的操作，比如为Statement对象设置参数，调用Statement接口提供的方法与数据库交互等。</li>
<li><strong>ParameterHandler</strong>：当MyBatis框架使用的Statement类型为PrepareStatement或CallableStatement时，ParameterHandler用于为Statement对象参数占位符设置值。</li>
<li><strong>ResultSetHandler</strong>：ResultSetHandler封装了对JDBC ResultSet对象的操作。用以返回Select语句查询到的Java对象。</li>
<li><strong>TypeHandler</strong>：TypeHandler完成getXXX和setXXX时的类型转换，完成数据库类型和Java类型的映射（或者反之）。</li>
</ul>
<h2 id="工作关键点"><a href="#工作关键点" class="headerlink" title="工作关键点"></a>工作关键点</h2><p>了解了Mybatis的核心组件以后，我们再简单分析一下数据库交互的关键点：</p>
<ol>
<li>获取<code>SqlSession</code>组件（获取这个过程第一节讲过了），它实际上是<code>Executor</code>组件的外观，提供给用户更加易用友好的接口，体现了设计模式的<strong>外观模式</strong>。</li>
<li>真正执行SQL操作的是<code>Executor</code>组件，可以理解它为执行器。</li>
<li><code>Executor</code>会使用<code>StatementHandler</code>组件对JDBC的<code>Statement</code>对象进行操作。如果<code>Statement</code>的类型是<code>PrepareStatement</code>或者<code>CallableStatement</code>，则会通过<code>ParameterHandler</code>为参数占位符进行赋值。</li>
<li><code>ParameterHandler</code>赋值的时候会找到Java类型对应的<code>TypeHandler</code>对象，<code>TypeHandler</code>会调用<code>Statement</code>对象提供的setXXX()方法对参数占位符设置值。</li>
<li><code>StatementHandler</code>使用JDBC的<code>Statement</code>对象与数据库完成交互以后，当执行的SQL为select，<code>ResultSetHandler</code>组件会从<code>Statement</code>对象中获取<code>ResultSet</code>对象它转换成Java对象，返回给上层。</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>接下来就是各个组件的具体解析，以后有机会再写。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/06/10/Mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/" data-id="ckb905ao70000okug636l2j65" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" rel="tag">网络通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 16.67px;">JVM</a> <a href="/tags/LeetCode/" style="font-size: 18.33px;">LeetCode</a> <a href="/tags/Linux/" style="font-size: 11.67px;">Linux</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/mysql/" style="font-size: 20px;">mysql</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 13.33px;">并发编程</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.33px;">数据结构</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" style="font-size: 13.33px;">网络通信</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 11.67px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/">JVM面试题</a>
          </li>
        
          <li>
            <a href="/2020/06/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/">数据库设计三范式</a>
          </li>
        
          <li>
            <a href="/2020/06/24/applicationContext%E4%B8%AD%E7%9A%84Refresh-%E6%96%B9%E6%B3%95/">applicationContext中的Refresh()方法</a>
          </li>
        
          <li>
            <a href="/2020/06/23/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%E5%A4%A7%E6%80%BB%E7%BB%93/">阻塞队列存取方法区别大总结</a>
          </li>
        
          <li>
            <a href="/2020/06/22/synchronized%E5%92%8CLock%E5%AD%B0%E4%BC%98%E5%AD%B0%E5%8A%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F/">synchronized和Lock孰优孰劣，如何选择？</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 liqiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>