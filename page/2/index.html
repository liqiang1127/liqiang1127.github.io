<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>HDU_LIQIANG&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写点什么呢~">
<meta property="og:type" content="website">
<meta property="og:title" content="HDU_LIQIANG&#39;s Blog">
<meta property="og:url" content="https://github.com/liqiang1127/page/2/index.html">
<meta property="og:site_name" content="HDU_LIQIANG&#39;s Blog">
<meta property="og:description" content="写点什么呢~">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="liqiang">
<meta property="article:tag" content="Java CV">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="HDU_LIQIANG&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HDU_LIQIANG&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Java Coder</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/liqiang1127"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-5-最长回文子串" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/21/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/" class="article-date">
  <time datetime="2020-05-21T02:06:10.000Z" itemprop="datePublished">2020-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/21/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/">5.最长回文子串</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>数据规模是<strong>1000</strong>，其实是提示用$n^2$的算法</li>
<li>动态规划计算的时候需要注意数组边界</li>
<li>截取字符串的性能消耗大，可以先记住<code>start</code>和<code>max_len</code>，最后再截取</li>
<li>计算<code>dp</code>的时候要列有限</li>
</ul>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = (s[i] == s[j]) &amp;&amp; (dp[i+<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line"><span class="comment">// 剪枝条件 j-1 - (i+1) + 1 &lt; 2  </span></span><br><span class="line"><span class="comment">// 当区间只包含一个元素的时候，直接返回true</span></span><br></pre></td></tr></table></figure>



<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态规划写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="comment">// dp[i][j] 代表 s[i...j]是不是回文串</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">// 这一步其实没要 剪枝可以减掉</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 列优先填表</span></span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len ; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cs[i] != cs[j])</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j - i + <span class="number">1</span> &lt; <span class="number">4</span>)&#123;</span><br><span class="line">                    <span class="comment">// 区间长度是2，3的时候不需要计算</span></span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; max_len)&#123;</span><br><span class="line">                    max_len = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/21/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/" data-id="ckag59m8f0000ywug4xje2ppw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-update的作用和用法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/14/update%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%94%A8%E6%B3%95/" class="article-date">
  <time datetime="2020-05-14T10:26:45.000Z" itemprop="datePublished">2020-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/14/update%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%94%A8%E6%B3%95/">for update的作用和用法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、for-update的定义"><a href="#一、for-update的定义" class="headerlink" title="一、for update的定义"></a>一、for update的定义</h2><p>for update是一种行级锁，又叫排它锁，一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行．如果其它用户想更新该表中的数据行，则也必须对该表施加行级锁．即使多个用户对一个表均使用了共享更新，但也不允许两个事务同时对一个表进行更新，真正对表进行更新时，是以独占方式锁表，一直到提交或复原该事务为止。行锁永远是独占方式锁。</p>
<p>只有当出现如下之一的条件，才会释放共享更新锁：<br>1、执行提交（COMMIT）语句<br>2、退出数据库（LOG　OFF）<br>3、程序停止运行</p>
<h2 id="二、概念和用法"><a href="#二、概念和用法" class="headerlink" title="二、概念和用法"></a>二、概念和用法</h2><p>通常情况下，select语句是不会对数据加锁，妨碍影响其他的DML和DDL操作。同时，在多版本一致读机制的支持下，select语句也不会被其他类型语句所阻碍。</p>
<p>而select … for update 语句是我们经常使用手工加锁语句。在数据库中执行select … for update ,大家会发现会对数据库中的表或某些行数据进行锁表，在mysql中，如果查询条件带有主键，会锁行数据，如果没有，会锁表。</p>
<p> 由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table Lock (将整个资料表单给锁住)。</p>
<p>举个例子: 假设有张表user ，里面有 id 和 name 两列，id是主键。</p>
<p>例1: (明确指定主键，并且数据真实存在，row lock)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">3</span> <span class="keyword">and</span> <span class="keyword">name</span>=<span class="string">'Tom'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>例2: (明确指定主键，但数据不存在，无lock)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">0</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>例3: (主键不明确，table lock)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>&lt;&gt;<span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">LIKE</span> <span class="string">'%3%'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>例4: (无主键，table lock)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Tom'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>注意：<br>1、FOR UPDATE仅适用于InnoDB，且必须在事务处理模块(BEGIN/COMMIT)中才能生效。</p>
<p>2、要测试锁定的状况，可以利用MySQL的Command Mode(命令模式) ，开两个视窗来做测试。</p>
<p>3、Myisam 只支持表级锁，InnerDB支持行级锁 添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改。是表级锁时，不管是否查询到记录，都会锁定表。</p>
<h2 id="三、什么时候需要使用for-update？"><a href="#三、什么时候需要使用for-update？" class="headerlink" title="三、什么时候需要使用for update？"></a>三、什么时候需要使用for update？</h2><p>借助for update语句，我们可以在应用程序的层面手工实现数据加锁保护操作。就是那些需要业务层面数据独占时，可以考虑使用for update。</p>
<p>场景上，比如火车票订票，在屏幕上显示有票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。所以，在这个确认过程中，可以使用for update。</p>
<h2 id="四、for-update悲观锁"><a href="#四、for-update悲观锁" class="headerlink" title="四、for update悲观锁"></a><strong>四、for update悲观锁</strong></h2><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它解锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。就像for update，再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p>
<p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/14/update%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%94%A8%E6%B3%95/" data-id="cka6noped00008cugfq5tegku" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Resourse和-Autowire" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/14/Resourse%E5%92%8C-Autowire/" class="article-date">
  <time datetime="2020-05-14T06:59:20.000Z" itemprop="datePublished">2020-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/14/Resourse%E5%92%8C-Autowire/">@Resourse和@Autowire</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Resource和-Autowired"><a href="#Resource和-Autowired" class="headerlink" title="@Resource和@Autowired"></a>@Resource和@Autowired</h2><ul>
<li><code>@Resource</code>和<code>@Autowired</code>都可以用来装配bean，都可以用于字段或setter方法。<ul>
<li><code>@Autowired</code>默认<strong>按类型</strong>装配，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false。</li>
<li><code>@Resource</code>默认<strong>按名称</strong>装配，当找不到与名称匹配的bean时才按照类型进行装配。名称可以通过name属性指定，如果没有指定name属性，当注解写在字段上时，默认取字段名，当注解写在setter方法上时，默认取属性名进行装配。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：如果name属性一旦指定，就只会按照名称进行装配</p>
</blockquote>
<ul>
<li><code>@Autowire</code>和<code>@Qualifier</code>配合使用效果和<code>@Resource</code>一样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>) </span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"example"</span>)</span><br><span class="line"><span class="keyword">private</span> Example example;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"example"</span>)</span><br><span class="line"><span class="keyword">private</span> Example example;</span><br></pre></td></tr></table></figure>

<ul>
<li>@Resource装配顺序</li>
</ul>
<ol>
<li>如果同时指定name和type，则从容器中查找唯一匹配的bean装配，找不到则抛出异常</li>
<li>如果指定name属性，则从容器中查找名称匹配的bean装配，找不到则抛出异常</li>
<li>如果指定type属性，则从容器中查找类型唯一匹配的bean装配，找不到或者找到多个抛出异常</li>
<li>如果都不指定，则自动按照byName方式装配，如果没有匹配，则回退一个原始类型进行匹配，如果匹配则自动装配</li>
</ol>
<h2 id="表格对比"><a href="#表格对比" class="headerlink" title="表格对比"></a>表格对比</h2><table>
<thead>
<tr>
<th>注解对比</th>
<th>@Resource</th>
<th>@Autowire</th>
</tr>
</thead>
<tbody><tr>
<td>注解来源</td>
<td>JDK</td>
<td>Spring</td>
</tr>
<tr>
<td>装配方式</td>
<td>优先按名称</td>
<td>优先按类型</td>
</tr>
<tr>
<td>属性</td>
<td>name、type</td>
<td>required</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/14/Resourse%E5%92%8C-Autowire/" data-id="cka6fkvqx0000tgug6meu8gpr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-factoryBean和beanFactory" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/14/factoryBean%E5%92%8CbeanFactory/" class="article-date">
  <time datetime="2020-05-14T06:17:34.000Z" itemprop="datePublished">2020-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/14/factoryBean%E5%92%8CbeanFactory/">factoryBean和beanFactory</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文出处：<a href="https://zhuanlan.zhihu.com/p/87382038" target="_blank" rel="noopener">Spring中BeanFactory与FactoryBean的区别，你知道吗？</a></p>
</blockquote>
<p>在Spring中有BeanFactory和FactoryBean这2个接口，从名字来看很相似，比较容易搞混。</p>
<h2 id="一、BeanFactory"><a href="#一、BeanFactory" class="headerlink" title="一、BeanFactory"></a>一、BeanFactory</h2><p><code>BeanFactory</code>是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口，它定义了<code>getBean()</code>、<code>containsBean()</code>等管理Bean的通用方法。Spring的容器都是它的具体实现如：</p>
<ul>
<li>DefaultListableBeanFactory</li>
<li>XmlBeanFactory</li>
<li>ApplicationContext</li>
</ul>
<p>这些实现类又从不同的维度分别有不同的扩展。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，</span></span><br><span class="line">	<span class="comment">//如果需要得到工厂本身，需要转义</span></span><br><span class="line">	String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据bean的名字，获取在IOC容器中得到bean实例</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, @Nullable Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供对bean的检索，看看是否在IOC容器有这个名字的bean</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据bean名字得到bean实例，并同时判断这个bean是不是单例</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, @Nullable Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到bean实例的Class类型</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到bean的别名，如果根据别名检索，那么其原名也会被检索出来</span></span><br><span class="line">	String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h3><ul>
<li>从Ioc容器中获取Bean(byName or byType)</li>
<li>检索Ioc容器中是否包含指定的Bean</li>
<li>判断Bean是否为单例</li>
</ul>
<h2 id="二、FactoryBean"><a href="#二、FactoryBean" class="headerlink" title="二、FactoryBean"></a>二、FactoryBean</h2><p>首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p>
<h3 id="2-1-源码"><a href="#2-1-源码" class="headerlink" title="2.1 源码"></a>2.1 源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//从工厂中获取bean</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="comment">//获取Bean工厂创建的对象的类型</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line">	<span class="comment">//Bean工厂创建的对象是否是单例模式</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从它定义的接口可以看出，<code>FactoryBean</code>表现的是一个工厂的职责。 <strong>即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用<code>getObject()</code>返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上’<code>&amp;</code>‘符号。</strong></p>
<ul>
<li>getObject(‘name’)返回工厂中的实例</li>
<li>getObject(‘&amp;name’)返回工厂本身的实例</li>
</ul>
<p>通常情况下，bean 无须自己实现工厂模式，Spring 容器担任了工厂的 角色；但少数情况下，容器中的 bean 本身就是工厂，作用是产生其他 bean 实例。由工厂 bean 产生的其他 bean 实例，不再由 Spring 容器产生，因此与普通 bean 的配置不同，不再需要提供 class 元素。</p>
<h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><p>先定义一个Bean实现FactoryBean接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = <span class="string">"通过构造方法初始化实例"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 这里并不一定要返回MyBean自身的实例，可以是其他任何对象的实例。</span></span><br><span class="line">        <span class="comment">//如return new Student()...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean(<span class="string">"通过FactoryBean.getObject()创建实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyBean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyBean实现了FactoryBean接口的两个方法，getObject()是可以返回任何对象的实例的，这里测试就返回MyBean自身实例，且返回前给message字段赋值。同时在构造方法中也为message赋值。然后测试代码中先通过名称获取Bean实例，打印message的内容，再通过<code>&amp;+名称</code>获取实例并打印message内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= TestApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">FactoryBeanTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyBean myBean1 = (MyBean) context.getBean(<span class="string">"myBean"</span>);</span><br><span class="line">        System.out.println(<span class="string">"myBean1 = "</span> + myBean1.getMessage());</span><br><span class="line">        MyBean myBean2 = (MyBean) context.getBean(<span class="string">"&amp;myBean"</span>);</span><br><span class="line">        System.out.println(<span class="string">"myBean2 = "</span> + myBean2.getMessage());</span><br><span class="line">        System.out.println(<span class="string">"myBean1.equals(myBean2) = "</span> + myBean1.equals(myBean2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myBean1 = 通过FactoryBean.getObject()初始化实例</span><br><span class="line">myBean2 = 通过构造方法初始化实例</span><br><span class="line">myBean1.equals(myBean2) = <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-使用场景"><a href="#2-3-使用场景" class="headerlink" title="2.3 使用场景"></a>2.3 使用场景</h3><p>说了这么多，为什么要有<code>FactoryBean</code>这个东西呢，有什么具体的作用吗？<br>FactoryBean在Spring中最为典型的一个应用就是用来<strong>创建AOP的代理对象</strong>。</p>
<p>我们知道AOP实际上是Spring在运行时创建了一个代理对象，也就是说这个对象，是我们在运行时创建的，而不是一开始就定义好的，这很符合工厂方法模式。更形象地说，AOP代理对象通过Java的反射机制，在运行时创建了一个代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在Spring中就是——<code>ProxyFactoryBean</code>。</p>
<p>所以，FactoryBean为我们实例化Bean提供了一个更为灵活的方式，我们可以通过FactoryBean创建出更为复杂的Bean实例。</p>
<h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><ul>
<li>他们两个都是个工厂，但<code>FactoryBean</code>本质上还是一个Bean，也归<code>BeanFactory</code>管理</li>
<li><code>BeanFactory</code>是Spring容器的顶层接口，<code>FactoryBean</code>更类似于用户自定义的工厂接口。</li>
</ul>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p><code>BeanFactory</code>与<code>FactoryBean</code>的区别确实容易混淆，死记硬背是不行的，最好还是从源码层面，置于spring的环境中去理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/14/factoryBean%E5%92%8CbeanFactory/" data-id="cka6efimo0000k4ughenp092e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-45-跳跃游戏II" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/04/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/" class="article-date">
  <time datetime="2020-05-04T01:20:18.000Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/04/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/">45-跳跃游戏II</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>示例:</p>
<blockquote>
<p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/jump-game-ii" target="_blank" rel="noopener">传送门</a></p>
<h3 id="分析一下"><a href="#分析一下" class="headerlink" title="分析一下"></a>分析一下</h3><p><strong>贪心策略：每次选择下一跳最远的点。</strong></p>
<p>参数解释：</p>
<blockquote>
<p>steps：记录总跳数。</p>
<p>end：第steps跳跃的选择确定以后，能达到的最远边界。</p>
<p>max：记录从当前点能跳跃的最远距离</p>
<p>if( i == end )：每次当i走到end，也就是上一个steps能到达的最远边界的时候，更新end。也就是对上以steps能到达的所有点遍历了一遍，选出最远的点。</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>; <span class="comment">// 记录的是当前能跳到边界</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>; <span class="comment">// 记录在边界(end)中的点能跳到的最远距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            max = Math.max(max, i + nums[i]);</span><br><span class="line">            <span class="comment">// 只有当i == end才更新一次，</span></span><br><span class="line">            <span class="comment">// 当i==end 意味着max中存储了，这一次选择所有可能的点的最远跳跃距离</span></span><br><span class="line">            <span class="keyword">if</span>( i == end)&#123; <span class="comment">//遇到边界，就更新边界，并且步数加一</span></span><br><span class="line">                end = max;</span><br><span class="line">                steps++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/04/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/" data-id="ck9rt58410000n8ug1n29h9rz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-一条SQL更新语句是如何执行的" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/" class="article-date">
  <time datetime="2020-05-03T11:20:58.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/">日志系统：一条SQL更新语句是如何执行的?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>文章来源：<a href="https://time.geekbang.org/column/intro/139" target="_blank" rel="noopener">MySQL实战45讲</a></p>
<p>这门课很好，90块钱物超所值。支持大家购买正版。</p>
</blockquote>
<p>现有一个表</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br></pre></td></tr></table></figure>

<p>如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>

<p>更新语句和之前的查询语句一样，都是下图这个流程：</p>
<img src="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class title="Mysql逻辑架构图">

<p>你执行语句前要先连接数据库，这是连接器的工作。</p>
<p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p>
<p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p>
<p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触 MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log 和 binlog 在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。</p>
<h2 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h2><p>这里有一个形象的比喻：</p>
<p>《孔乙己》中的掌柜老板有一个<strong>粉板</strong>，用于记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的<strong>账本</strong>。</p>
<p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p>
<ul>
<li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li>
<li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li>
</ul>
<p>如果店里生意很忙，掌柜肯定是选择的第二种方式，因为前者操作太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p>
<p>同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p>
<p>而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 <strong>WAL</strong> 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p>
<p><strong>具体来说</strong>，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 <strong>redo log(粉板)</strong>里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到<strong>磁盘(账本)</strong>里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p>
<p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p>
<p>与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>
<img src="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/2.png" class title="redo_log写入">

<p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe。</strong></p>
<p>要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p>
<h2 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/" data-id="ck9r73has0000dsugdeix9dzt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-一条SQL查询语句是如何执行的" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/" class="article-date">
  <time datetime="2020-05-03T08:44:23.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/">基础架构：一条SQL查询语句是如何执行的?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>文章来源：<a href="https://time.geekbang.org/column/intro/139" target="_blank" rel="noopener">MySQL实战45讲</a></p>
<p>这门课很好，90块钱物超所值。支持大家购买正版。</p>
</blockquote>
<p>我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个 ID 字段，在执行下面这个查询语句时：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10；</span><br></pre></td></tr></table></figure>

<p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。</p>
<p>下面我给出的是 MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。</p>
<img src="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class title="Mysql逻辑架构图">

<p>大体来说，MySQL 可以分为 <strong>Server 层</strong> 和<strong>存储引擎层</strong>两部分。</p>
<p><strong>Server 层</strong>包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>而<strong>存储引擎层</strong>负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>
<p>从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。</p>
<h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，<strong>连接器负责跟客户端建立连接、获取权限、维持和管理连接</strong>。连接命令一般是这么写的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h<span class="variable">$ip</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> -p</span><br></pre></td></tr></table></figure>

<p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>
<ul>
<li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li>
<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li>
</ul>
<p>一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。需要使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>
<img src="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/show-processlist.png" class title="show-processlist">

<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout</code> 控制的，<strong>默认值是 8 小时</strong>。</p>
<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
<ul>
<li><p><strong>长连接:</strong>连接成功后，如果客户端持续有请求，则一直使用同一个连接。</p>
</li>
<li><p><strong>短连接</strong>则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>
</li>
</ul>
<p>建立连接的过程通常是比较复杂的，<strong>尽量使用长连接</strong>。</p>
<p>但是全部使用长连接后，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>
<p>怎么解决这个问题呢？你可以考虑以下<strong>两种方案</strong>。</p>
<ol>
<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>
<li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>
</ol>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。</p>
<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>
<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。</p>
<p>需要注意的是，<strong>MySQL 8.0 版本直接将查询缓存的整块功能删掉了</strong>，也就是说 8.0 开始彻底没有这个功能了。</p>
<h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>分析器先会做<strong>“词法分析”</strong>。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p>
<p>做完了这些识别以后，就要做<strong>“语法分析”</strong>。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p>
<p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID=1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; <span class="keyword">check</span> the <span class="keyword">manual</span> that corresponds <span class="keyword">to</span> your MySQL <span class="keyword">server</span> <span class="keyword">version</span> <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> <span class="keyword">use</span> near <span class="string">'elect * from t where ID=1'</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure>

<ul>
<li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li>
<li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li>
</ul>
<p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>
<h3 id="权限的拦截是在执行器上判断的"><a href="#权限的拦截是在执行器上判断的" class="headerlink" title="权限的拦截是在执行器上判断的"></a>权限的拦截是在执行器上判断的</h3><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): <span class="keyword">SELECT</span> command denied <span class="keyword">to</span> <span class="keyword">user</span> <span class="string">'b'</span>@<span class="string">'localhost'</span> <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">'T'</span></span><br></pre></td></tr></table></figure>

<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，<strong>去使用这个引擎提供的接口。</strong></p>
<p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>
<ul>
<li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ul>
<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>
<p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>
<p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟 rows_examined 并不是完全相同的。</strong>我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天我给你介绍了 MySQL 的逻辑架构，希望你对一个 SQL 语句完整执行流程的各个阶段有了一个初步的印象。由于篇幅的限制，我只是用一个查询的例子将各个环节过了一遍。如果你还对每个环节的展开细节存有疑问，也不用担心，后续在实战章节中我还会再提到它们。</p>
<h2 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h2><p>如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p>
<h3 id="问题解答："><a href="#问题解答：" class="headerlink" title="问题解答："></a>问题解答：</h3><p><strong>答案是：优化器</strong>，有评论提到：</p>
<p>《高性能mysql》里提到解析器和预处理器。</p>
<p>解析器处理语法和解析查询, 生成一课对应的解析树。</p>
<p>预处理器进一步检查解析树的合法。比如: 数据表和数据列是否存在, 别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器。</p>
<p>所以我觉得课后习题的错误应该发生在在分析器处理阶段&gt;_&lt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/" data-id="ck9r73haw0001dsug3a78fmce" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spring模块划分" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/01/spring%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86/" class="article-date">
  <time datetime="2020-05-01T06:09:09.000Z" itemprop="datePublished">2020-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/01/spring%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86/">spring-framework模块划分</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a href="https://github.com/spring-projects/spring-framework">spring-frame官方仓库</a></p>
<p><a href="https://spring.io/" target="_blank" rel="noopener">spring官网</a></p>
<p><a href="https://www.cnblogs.com/MrZhouZ/p/11530578.html" target="_blank" rel="noopener">Spring框架的前世今生与系统架构</a></p>
</blockquote>
<h2 id="spring-framework总览"><a href="#spring-framework总览" class="headerlink" title="spring-framework总览"></a>spring-framework总览</h2><p>spring-framework官方仓库中把spring的一些功能进行了拆解，分在不同模块中。这里就简单总结一下每个模块的作用，对spring-framework有一个总体上的认识。</p>
<p>首先来看一下spring-framework的整个架构：</p>
<img src="/2020/05/01/spring%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86/1.png" class title="spring-framework模块">



<p>可以看到官方仓库把spring-framework分成了21个模块，让开发者可以按需引入。</p>
<img src="/2020/05/01/spring%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86/2.png" class title="spring-framework模块">



<h2 id="分模块简介"><a href="#分模块简介" class="headerlink" title="分模块简介"></a>分模块简介</h2><p>接下来对各个模块进行一些最简单的介绍</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>模块名</th>
<th>作用简介</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>spring-aop</td>
<td>给spring-frame提供aop的支持，也就是面向切面的编程的能力。</td>
</tr>
<tr>
<td>2</td>
<td>spring-aspects</td>
<td>spring-aspects 模块集成自 AspectJ 框架，主要是为 Spring AOP 提供多种 AOP 实现方法。</td>
</tr>
<tr>
<td>3</td>
<td>spring-beans</td>
<td><strong>核心模块</strong>。beans包的核心功能就是对Bean对象生命周期的管理，包含Bean的定义、解析和创建等。</td>
</tr>
<tr>
<td>4</td>
<td>spring-context-indexer</td>
<td>spring-context-indexer 模块是 Spring 的类管理组件和 Classpath 扫描。</td>
</tr>
<tr>
<td>5</td>
<td>spring-context-support</td>
<td>spring-context-support 模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器。</td>
</tr>
<tr>
<td>6</td>
<td>spring-context</td>
<td><strong>核心模块</strong>。spring-context 模块构架于核心模块之上，扩展了 BeanFactory，为她添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。</td>
</tr>
<tr>
<td>7</td>
<td>spring-core</td>
<td><strong>核心模块</strong>。core模块的功能实现的反向控制与依赖注入、Bean配置与加载。</td>
</tr>
<tr>
<td>8</td>
<td>spring-expression</td>
<td><strong>核心模块</strong>。又称SpEL，spring-expression 模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等。</td>
</tr>
<tr>
<td>9</td>
<td>spring-instrument</td>
<td>spring-instrument 模块是基于 JAVA SE 中的”java.lang.instrument”进行设计的，应该算是 AOP的一个支援模块。</td>
</tr>
<tr>
<td>10</td>
<td>spring-jcl</td>
<td>spring-jcl模这个模块是spring源码里最基础的模块没有依赖其他模块，它是为了兼容不同版本的日志系统。</td>
</tr>
<tr>
<td>11</td>
<td>spring-jdbc</td>
<td>spring-jdbc 模块是 Spring 提供的 JDBC 抽象框架的主要实现模块，用于简化 Spring JDBC 操作 。</td>
</tr>
<tr>
<td>12</td>
<td>spring-jms</td>
<td>spring-jms 模块（Java Messaging Service）能够发送和接收信息。</td>
</tr>
<tr>
<td>13</td>
<td>spring-messaging</td>
<td>即 spring-messaging 模块，是从 Spring4 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</td>
</tr>
<tr>
<td>14</td>
<td>spring-orm</td>
<td>spring-orm 模块是 ORM 框架支持模块，主要集成 Hibernate, Java Persistence API (JPA) 和Java Data Objects (JDO) 用于资源管理、数据访问对象(DAO)的实现和事务策略。</td>
</tr>
<tr>
<td>15</td>
<td>spring-oxm</td>
<td>spring-oxm 模块主要提供一个抽象层以支撑 OXM（OXM 是 Object-to-XML-Mapping 的缩写，它是一个 O/M-mapper，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象）</td>
</tr>
<tr>
<td>16</td>
<td>spring-test</td>
<td>spring-test 模块，主要为测试提供支持的。</td>
</tr>
<tr>
<td>17</td>
<td>spring-tx</td>
<td>spring-tx 模块是 Spring JDBC 事务控制实现模块。</td>
</tr>
<tr>
<td>18</td>
<td>spring-web</td>
<td>spring-web 模块为 Spring 提供了最基础 Web 支持。</td>
</tr>
<tr>
<td>19</td>
<td>spring-webflux</td>
<td>spring-webflux 是一个新的非堵塞函数式 Reactive Web 框架。</td>
</tr>
<tr>
<td>20</td>
<td>spring-webmvc</td>
<td>spring-webmvc 模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC。</td>
</tr>
<tr>
<td>21</td>
<td>spring-webscoket</td>
<td>spring-websocket 模块主要是与 Web 前端的全双工通讯的协议。</td>
</tr>
</tbody></table>
<h2 id="模块间的配合"><a href="#模块间的配合" class="headerlink" title="模块间的配合"></a>模块间的配合</h2><p>回顾一下上面的架构图</p>
<img src="/2020/05/01/spring%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86/1.png" class title="spring-frame模块">

<h3 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h3><p>由spring-beans、spring-core、spring-context和spring-expression（Spring Expression Language,SpEL） 4 个模块组成。</p>
<p><strong>spring-core</strong> 和 spring-beans 模块是 Spring 框架的核心模块，包含了控制反转（Inversion of Control, IOC）和依赖注入（Dependency Injection, DI）。BeanFactory 接口是 Spring 框架中的核心接口，它是工厂模式的具体实现。BeanFactory 使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。但 BeanFactory 容器实例化后并不会自动实例化 Bean，只有当 Bean 被使用时 BeanFactory 容器才会对该 Bean 进行实例化与依赖关系的装配。</p>
<p><strong>spring-context</strong> 模块构架于核心模块之上，他扩展了 BeanFactory，为她添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。此外该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext 是该模块的核心接口，她的超类是 BeanFactory。与BeanFactory 不同，pplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态。</p>
<p><strong>spring-context-support</strong> 模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器。spring-context-indexer 模块是 Spring 的类管理组件和 Classpath 扫描。</p>
<p><strong>spring-expression</strong>模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等。它的语法类似于传统 EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。这种语言的特性是基于 Spring 产品的需求而设计，他可以非常方便地同 Spring IOC 进行交互。 </p>
<h3 id="AOP和设备支持"><a href="#AOP和设备支持" class="headerlink" title="AOP和设备支持"></a>AOP和设备支持</h3><p>由 spring-aop、spring-aspects 和 spring-instrument 3 个模块组成。</p>
<p><strong>spring-aop</strong> 是 Spring 的另一个核心模块，是 AOP 主要的实现模块。作为继 OOP 后，对程序员影响最大的编程思想之一，AOP 极大地开拓了人们对于编程的思路。在 Spring 中，他是以 JVM 的动态代理技术为基础，然后设计出了一系列的 AOP 横切实现，比如前置通知、返回通知、异常通知等，同时，Pointcut 接口来匹配切入点，可以使用现有的切入点来设计横切面，也可以扩展相关方法根据需求进行切入。</p>
<p><strong>spring-aspects</strong> 模块集成自 AspectJ 框架，主要是为 Spring AOP 提供多种 AOP 实现方法。</p>
<p><strong>spring-instrument</strong>模块是基于 JAVA SE 中的”java.lang.instrument”进行设计的，应该算是 AOP的一个支援模块，主要作用是在 JVM 启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现 AOP 的功能。在分类里，我把他分在了 AOP 模块下，在 Spring 官方文档里对这个地方也有点含糊不清，这里是纯个人观点。</p>
<h3 id="数据访问与集成"><a href="#数据访问与集成" class="headerlink" title="数据访问与集成"></a>数据访问与集成</h3><p>由 spring-jdbc、spring-tx、spring-orm、spring-jms 和 spring-oxm 5 个模块组成。</p>
<p><strong>spring-jdbc</strong> 模块是 Spring 提供的 JDBC 抽象框架的主要实现模块，用于简化 Spring JDBC 操作 。主要是提供 JDBC 模板方式、关系数据库对象化方式、SimpleJdbc 方式、事务管理来简化 JDBC 编程，主要实现类是 JdbcTemplate、SimpleJdbcTemplate 以及 NamedParameterJdbcTemplate。</p>
<p><strong>spring-tx</strong> 模块是 Spring JDBC 事务控制实现模块。使用 Spring 框架，它对事务做了很好的封装，通过它的 AOP 配置，可以灵活的配置在任何一层；但是在很多的需求和应用，直接使用 JDBC 事务控制还是有其优势的。其实，事务是以业务逻辑为基础的；一个完整的业务应该对应业务层里的一个方法；如果业务操作失败，则整个事务回滚；所以，事务控制是绝对应该放在业务层的；但是，持久层的设计则应该遵循一个很重要的原则：保证操作的原子性，即持久层里的每个方法都应该是不可以分割的。所以，在使用 Spring JDBC 事务控制时，应该注意其特殊性。</p>
<p><strong>spring-orm</strong>模块是 ORM 框架支持模块，主要集成 Hibernate, Java Persistence API (JPA) 和Java Data Objects (JDO) 用于资源管理、数据访问对象(DAO)的实现和事务策略。</p>
<p><strong>spring-oxm</strong> 模块主要提供一个抽象层以支撑 OXM（OXM 是 Object-to-XML-Mapping 的缩写，它是一个 O/M-mapper，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象），例如：JAXB, Castor, XMLBeans, JiBX 和 XStream 等。</p>
<p><strong>spring-jms</strong>模块（Java Messaging Service）能够发送和接收信息，自 Spring Framework 4.1 以后，他还提供了对 spring-messaging 模块的支撑。 </p>
<h3 id="Web组件"><a href="#Web组件" class="headerlink" title="Web组件"></a>Web组件</h3><p>由 spring-web、spring-webmvc、spring-websocket 和 spring-webflux 4 个模块组成。</p>
<p><strong>spring-web</strong>模块为 Spring 提供了最基础 Web 支持，主要建立于核心容器之上，通过 Servlet 或者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持。</p>
<p><strong>spring-webmvc</strong>模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC（model-view-Controller）的 Web 应用。</p>
<p><strong>spring-websocket</strong>模块主要是与 Web 前端的全双工通讯的协议。</p>
<p><strong>spring-webflux</strong>是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。 </p>
<h3 id="通信报文"><a href="#通信报文" class="headerlink" title="通信报文"></a>通信报文</h3><p><strong>spring-messaging</strong> 模块，是从 Spring4 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。 </p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p><strong>spring-test</strong> 模块，主要为测试提供支持的，毕竟在不需要发布（程序）到你的应用服务器或者连接到其他企业设施的情况下能够执行一些集成测试或者其他测试对于任何企业都是非常重要的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/01/spring%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86/" data-id="ck9qswfqq001y2cugffoa37u1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-index-concept" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/28/mysql-index-concept/" class="article-date">
  <time datetime="2020-04-28T12:48:10.000Z" itemprop="datePublished">2020-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/mysql-index-concept/">聚集索引&amp;非聚集索引&amp;覆盖索引总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-索引简介"><a href="#一-索引简介" class="headerlink" title="一.索引简介"></a>一.索引简介</h2><p>众所周知，索引是关系型数据库中给数据库表中一列或多列的值排序后的存储结构，SQL的主流索引结构有B+树以及Hash结构，聚集索引以及非聚集索引用的是B+树索引。这篇文章会总结MySQL的InnoDB和MyISAM两种引擎的索引。</p>
<h2 id="二-聚集索引"><a href="#二-聚集索引" class="headerlink" title="二.聚集索引"></a>二.聚集索引</h2><p>聚集（clustered）索引，也叫聚簇索引。</p>
<blockquote>
<p>定义：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。</p>
</blockquote>
<p>单单从定义来看是不是显得有点抽象，打个比方，一个表就像是我们以前用的新华字典，聚集索引就像是拼音目录，而每个字存放的页码就是我们的数据物理地址，我们如果要查询一个“哇”字，我们只需要查询“哇”字对应在新华字典拼音目录对应的页码，就可以查询到对应的“哇”字所在的位置，而拼音目录对应的A-Z的字顺序，和新华字典实际存储的字的顺序A-Z也是一样的，如果我们中文新出了一个字，拼音开头第一个是B，那么他插入的时候也要按照拼音目录顺序插入到A字的后面，现在用一个简单的示意图来大概说明一下在数据库中的样子：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>id</th>
<th>username</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>0x01</td>
<td>1</td>
<td>小明</td>
<td>90</td>
</tr>
<tr>
<td>0x02</td>
<td>2</td>
<td>小红</td>
<td>80</td>
</tr>
<tr>
<td>0x03</td>
<td>3</td>
<td>小华</td>
<td>92</td>
</tr>
<tr>
<td>..</td>
<td>..</td>
<td>..</td>
<td>..</td>
</tr>
<tr>
<td>0xff</td>
<td>256</td>
<td>小英</td>
<td>70</td>
</tr>
</tbody></table>
<p>注：第一列的地址表示该行数据在磁盘中的物理地址，后面三列才是我们SQL里面用的表里的列，其中id是主键，建立了聚集索引。</p>
<p>结合上面的表格就可以理解这句话了吧：数据行的物理顺序与列值的<strong>顺序相同</strong>，如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后。而且由于物理排列方式与聚集索引的顺序相同，所以也就只能建立一个聚集索引了。</p>
<img src="/2020/04/28/mysql-index-concept/1.png" class title="ss">

<p><strong>聚集索引实际存放的示意图</strong></p>
<p>从上图可以看出聚集索引的好处了，索引的叶子节点就是对应的数据节点（MySQL的MyISAM除外，此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别），可以直接获取到对应的全部列的数据，而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询，后面会详细讲。因此在查询方面，聚集索引的速度往往会更占优势。</p>
<h3 id="创建聚集索引"><a href="#创建聚集索引" class="headerlink" title="创建聚集索引"></a>创建聚集索引</h3><p>如果不创建索引，系统会自动创建一个隐含列作为表的聚集索引。</p>
<ol>
<li><p>创建表的时候指定主键（注意：SQL Sever默认主键为聚集索引，也可以指定为非聚集索引，而MySQL里主键就是聚集索引）</p>
</li>
<li><p>创建表后添加聚集索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> primary <span class="keyword">key</span>(colum_name)</span><br></pre></td></tr></table></figure>

<p>值得注意的是，最好还是在创建表的时候添加聚集索引，由于聚集索引的物理顺序上的特殊性，因此如果再在上面创建索引的时候会根据索引列的排序移动全部数据行上面的顺序，会非常地耗费时间以及性能。</p>
</li>
</ol>
<h2 id="三-非聚集索引"><a href="#三-非聚集索引" class="headerlink" title="三.非聚集索引"></a>三.非聚集索引</h2><p>非聚集（unclustered）索引。</p>
<blockquote>
<p>定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。</p>
</blockquote>
<p>其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成<strong>普通索引</strong>，<strong>唯一索引</strong>，<strong>全文索引</strong>。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的偏旁字典，他结构顺序与实际存放顺序不一定一致。</p>
<img src="/2020/04/28/mysql-index-concept/2.png" class title="ss">

<h3 id="非聚集索引的二次查询问题"><a href="#非聚集索引的二次查询问题" class="headerlink" title="非聚集索引的二次查询问题"></a>非聚集索引的二次查询问题</h3><p>非聚集索引叶节点仍然是索引节点，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据。</p>
<p>如有以下表t1：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>username</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>小明</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>小红</td>
<td>80</td>
</tr>
<tr>
<td>3</td>
<td>小华</td>
<td>92</td>
</tr>
<tr>
<td>..</td>
<td>..</td>
<td>..</td>
</tr>
<tr>
<td>256</td>
<td>小英</td>
<td>70</td>
</tr>
</tbody></table>
<p>以及聚集索引clustered index(id), 非聚集索引<strong>index(username)</strong>。</p>
<p>使用以下语句进行查询，不需要进行二次查询，直接就可以从非聚集索引的节点里面就可以获取到查询列的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, username <span class="keyword">from</span> t1 <span class="keyword">where</span> username = <span class="string">'小明'</span></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> t1 <span class="keyword">where</span> username = <span class="string">'小明'</span></span><br></pre></td></tr></table></figure>

<p>但是使用以下语句进行查询，就需要二次的查询去获取原数据行的score：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username, score <span class="keyword">from</span> t1 <span class="keyword">where</span> username = <span class="string">'小明'</span></span><br></pre></td></tr></table></figure>

<p><strong>原因是score不在索引中，所以得回表查询。</strong></p>
<h3 id="解决办法：覆盖索引"><a href="#解决办法：覆盖索引" class="headerlink" title="解决办法：覆盖索引"></a>解决办法：覆盖索引</h3><blockquote>
<p>如果查询的内容（select col1, col2），col1和col2都在索引中，那就不用回表了。满足这个条件就叫覆盖索引。</p>
</blockquote>
<p>要注意使用复合索引需要满足最左侧索引的原则，也就是查询的时候如果where条件里面没有最左边的一到多列，索引就不会起作用。</p>
<p>在SQL Server中还有include的用法，可以把非聚集索引里包含的列包含进来，而不一定需要建立复合索引。</p>
<h2 id="四-总结与使用心得"><a href="#四-总结与使用心得" class="headerlink" title="四.总结与使用心得"></a>四.总结与使用心得</h2><ol>
<li>使用聚集索引的查询效率要比非聚集索引的效率要高，但是如果需要频繁去改变聚集索引的值，写入性能并不高，因为需要移动对应数据的物理位置。</li>
<li>非聚集索引在查询的时候可以的话就避免二次查询，这样性能会大幅提升。</li>
<li>不是所有的表都适合建立索引，只有数据量大表才适合建立索引，且建立在选择性高的列上面性能会更好。</li>
</ol>
<blockquote>
<p>文章来源：<a href="https://www.cnblogs.com/s-b-b/p/8334593.html" target="_blank" rel="noopener">[聚集索引与非聚集索引的总结]</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/04/28/mysql-index-concept/" data-id="ck9qswfqo001q2cug5q2nd82r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-config" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/28/mysql-config/" class="article-date">
  <time datetime="2020-04-28T11:48:51.000Z" itemprop="datePublished">2020-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/mysql-config/">Mysql5.6&amp;5.7配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>MySQL 5.6 &amp; 5.7 最优配置模板</strong></p>
<p>Inside 君整理了一份最新基于 MySQL 5.6 和 5.7 的配置文件模板，基本上可以说覆盖 90% 的调优选项，用户只需根据自己的服务器配置稍作修改即可，如 InnoDB 缓冲池的大小、IO 能力（innodb_buffer_pool_size，innodb_io_capacity）。特别注意，这份配置文件不用修改，可以直接运行在 MySQL 5.6 和 5.7 的版本下，这里使用了小小的技巧，具体可看配置文件。如果配置参数存在问题，也可以及时反馈 Inside 君，我们一起成长。</p>
<p>触发 Inside 君做这件事情的原因是大部分网络上的 MySQL 配置文件都非常非常古老，大多都是基于 MySQL 5.1 的版本，这导致了绝大部分 MySQL 并没有运行在最优的环境，从而导致一些错误的使用，亦或是灾难性事故的发生，比如数据丢失，主从数据不一致等。而这些问题早在 5.6 版本及以后的版本中得到了解决。</p>
<p>最后，抛弃你那所谓的、陈旧的、错误的 MySQL 配置文件，面向一个崭新的高性能、高可靠、高可扩展 MySQL 时代，你要做的就是下载这份配置文件并用于你的生产环境。</p>
<p>insidemysql_my.cnf：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">user&#x3D;david</span><br><span class="line">password&#x3D;88888888</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">########basic settings########</span><br><span class="line">server-id &#x3D; 11 </span><br><span class="line">port &#x3D; 3306</span><br><span class="line">user &#x3D; mysql</span><br><span class="line">bind_address &#x3D; 10.166.224.32</span><br><span class="line">autocommit &#x3D; 0</span><br><span class="line">character_set_server&#x3D;utf8mb4</span><br><span class="line">skip_name_resolve &#x3D; 1</span><br><span class="line">max_connections &#x3D; 800</span><br><span class="line">max_connect_errors &#x3D; 1000</span><br><span class="line">datadir &#x3D; &#x2F;data&#x2F;mysql_data</span><br><span class="line">transaction_isolation &#x3D; READ-COMMITTED</span><br><span class="line">explicit_defaults_for_timestamp &#x3D; 1</span><br><span class="line">join_buffer_size &#x3D; 134217728</span><br><span class="line">tmp_table_size &#x3D; 67108864</span><br><span class="line">tmpdir &#x3D; &#x2F;tmp</span><br><span class="line">max_allowed_packet &#x3D; 16777216</span><br><span class="line">sql_mode &#x3D; &quot;STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER&quot;</span><br><span class="line">interactive_timeout &#x3D; 1800</span><br><span class="line">wait_timeout &#x3D; 1800</span><br><span class="line">read_buffer_size &#x3D; 16777216</span><br><span class="line">read_rnd_buffer_size &#x3D; 33554432</span><br><span class="line">sort_buffer_size &#x3D; 33554432</span><br><span class="line">########log settings########</span><br><span class="line">log_error &#x3D; error.log</span><br><span class="line">slow_query_log &#x3D; 1</span><br><span class="line">slow_query_log_file &#x3D; slow.log</span><br><span class="line">log_queries_not_using_indexes &#x3D; 1</span><br><span class="line">log_slow_admin_statements &#x3D; 1</span><br><span class="line">log_slow_slave_statements &#x3D; 1</span><br><span class="line">log_throttle_queries_not_using_indexes &#x3D; 10</span><br><span class="line">expire_logs_days &#x3D; 90</span><br><span class="line">long_query_time &#x3D; 2</span><br><span class="line">min_examined_row_limit &#x3D; 100</span><br><span class="line">########replication settings########</span><br><span class="line">master_info_repository &#x3D; TABLE</span><br><span class="line">relay_log_info_repository &#x3D; TABLE</span><br><span class="line">log_bin &#x3D; bin.log</span><br><span class="line">sync_binlog &#x3D; 1</span><br><span class="line">gtid_mode &#x3D; on</span><br><span class="line">enforce_gtid_consistency &#x3D; 1</span><br><span class="line">log_slave_updates</span><br><span class="line">binlog_format &#x3D; row </span><br><span class="line">relay_log &#x3D; relay.log</span><br><span class="line">relay_log_recovery &#x3D; 1</span><br><span class="line">binlog_gtid_simple_recovery &#x3D; 1</span><br><span class="line">slave_skip_errors &#x3D; ddl_exist_errors</span><br><span class="line">########innodb settings########</span><br><span class="line">innodb_page_size &#x3D; 8192</span><br><span class="line">innodb_buffer_pool_size &#x3D; 6G</span><br><span class="line">innodb_buffer_pool_instances &#x3D; 8</span><br><span class="line">innodb_buffer_pool_load_at_startup &#x3D; 1</span><br><span class="line">innodb_buffer_pool_dump_at_shutdown &#x3D; 1</span><br><span class="line">innodb_lru_scan_depth &#x3D; 2000</span><br><span class="line">innodb_lock_wait_timeout &#x3D; 5</span><br><span class="line">innodb_io_capacity &#x3D; 4000</span><br><span class="line">innodb_io_capacity_max &#x3D; 8000</span><br><span class="line">innodb_flush_method &#x3D; O_DIRECT</span><br><span class="line">innodb_file_format &#x3D; Barracuda</span><br><span class="line">innodb_file_format_max &#x3D; Barracuda</span><br><span class="line">innodb_log_group_home_dir &#x3D; &#x2F;redolog&#x2F;</span><br><span class="line">innodb_undo_directory &#x3D; &#x2F;undolog&#x2F;</span><br><span class="line">innodb_undo_logs &#x3D; 128</span><br><span class="line">innodb_undo_tablespaces &#x3D; 3</span><br><span class="line">innodb_flush_neighbors &#x3D; 1</span><br><span class="line">innodb_log_file_size &#x3D; 4G</span><br><span class="line">innodb_log_buffer_size &#x3D; 16777216</span><br><span class="line">innodb_purge_threads &#x3D; 4</span><br><span class="line">innodb_large_prefix &#x3D; 1</span><br><span class="line">innodb_thread_concurrency &#x3D; 64</span><br><span class="line">innodb_print_all_deadlocks &#x3D; 1</span><br><span class="line">innodb_strict_mode &#x3D; 1</span><br><span class="line">innodb_sort_buffer_size &#x3D; 67108864 </span><br><span class="line">########semi sync replication settings########</span><br><span class="line">plugin_dir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;lib&#x2F;plugin</span><br><span class="line">plugin_load &#x3D; &quot;rpl_semi_sync_master&#x3D;semisync_master.so;rpl_semi_sync_slave&#x3D;semisync_slave.so&quot;</span><br><span class="line">loose_rpl_semi_sync_master_enabled &#x3D; 1</span><br><span class="line">loose_rpl_semi_sync_slave_enabled &#x3D; 1</span><br><span class="line">loose_rpl_semi_sync_master_timeout &#x3D; 5000</span><br><span class="line"></span><br><span class="line">[mysqld-5.7]</span><br><span class="line">innodb_buffer_pool_dump_pct &#x3D; 40</span><br><span class="line">innodb_page_cleaners &#x3D; 4</span><br><span class="line">innodb_undo_log_truncate &#x3D; 1</span><br><span class="line">innodb_max_undo_log_size &#x3D; 2G</span><br><span class="line">innodb_purge_rseg_truncate_frequency &#x3D; 128</span><br><span class="line">binlog_gtid_simple_recovery&#x3D;1</span><br><span class="line">log_timestamps&#x3D;system</span><br><span class="line">transaction_write_set_extraction&#x3D;MURMUR32</span><br><span class="line">show_compatibility_56&#x3D;on</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作者：殷建卫</p>
<p>链接：<a href="https://www.yuque.com/yinjianwei/vyrvkf/tb8uaw" target="_blank" rel="noopener">https://www.yuque.com/yinjianwei/vyrvkf/tb8uaw</a></p>
<p>来源：<a href="https://www.yuque.com/yinjianwei/vyrvkf" target="_blank" rel="noopener">殷建卫 - 架构笔记</a></p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/04/28/mysql-config/" data-id="ck9qswfqi001b2cug9762814v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" rel="tag">网络通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 16px;">JVM</a> <a href="/tags/LeetCode/" style="font-size: 18px;">LeetCode</a> <a href="/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/Spring/" style="font-size: 14px;">Spring</a> <a href="/tags/mysql/" style="font-size: 20px;">mysql</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12px;">数据结构</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" style="font-size: 14px;">网络通信</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/17/b-treeContains/">mysql中3层的B+树能存多少条数据？</a>
          </li>
        
          <li>
            <a href="/2020/06/12/ConcurrentHashMap%E5%92%8CHashTable/">ConcurrentHashMap和HashTable</a>
          </li>
        
          <li>
            <a href="/2020/06/10/Mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/">Mybatis核心组件</a>
          </li>
        
          <li>
            <a href="/2020/06/09/HashMap/">HashMap</a>
          </li>
        
          <li>
            <a href="/2020/06/06/Mysql%E5%92%8CRedis%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/">Mysql和Redis双写一致性</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 liqiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>