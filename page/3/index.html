<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>HDU_LIQIANG&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写点什么呢~">
<meta property="og:type" content="website">
<meta property="og:title" content="HDU_LIQIANG&#39;s Blog">
<meta property="og:url" content="https://github.com/liqiang1127/page/3/index.html">
<meta property="og:site_name" content="HDU_LIQIANG&#39;s Blog">
<meta property="og:description" content="写点什么呢~">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="liqiang">
<meta property="article:tag" content="Java CV">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="HDU_LIQIANG&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HDU_LIQIANG&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Java Coder</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/liqiang1127"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-factoryBean和beanFactory" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/14/factoryBean%E5%92%8CbeanFactory/" class="article-date">
  <time datetime="2020-05-14T06:17:34.000Z" itemprop="datePublished">2020-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/14/factoryBean%E5%92%8CbeanFactory/">factoryBean和beanFactory</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文出处：<a href="https://zhuanlan.zhihu.com/p/87382038" target="_blank" rel="noopener">Spring中BeanFactory与FactoryBean的区别，你知道吗？</a></p>
</blockquote>
<p>在Spring中有BeanFactory和FactoryBean这2个接口，从名字来看很相似，比较容易搞混。</p>
<h2 id="一、BeanFactory"><a href="#一、BeanFactory" class="headerlink" title="一、BeanFactory"></a>一、BeanFactory</h2><p><code>BeanFactory</code>是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口，它定义了<code>getBean()</code>、<code>containsBean()</code>等管理Bean的通用方法。Spring的容器都是它的具体实现如：</p>
<ul>
<li>DefaultListableBeanFactory</li>
<li>XmlBeanFactory</li>
<li>ApplicationContext</li>
</ul>
<p>这些实现类又从不同的维度分别有不同的扩展。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，</span></span><br><span class="line">	<span class="comment">//如果需要得到工厂本身，需要转义</span></span><br><span class="line">	String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据bean的名字，获取在IOC容器中得到bean实例</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, @Nullable Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供对bean的检索，看看是否在IOC容器有这个名字的bean</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据bean名字得到bean实例，并同时判断这个bean是不是单例</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, @Nullable Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到bean实例的Class类型</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到bean的别名，如果根据别名检索，那么其原名也会被检索出来</span></span><br><span class="line">	String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h3><ul>
<li>从Ioc容器中获取Bean(byName or byType)</li>
<li>检索Ioc容器中是否包含指定的Bean</li>
<li>判断Bean是否为单例</li>
</ul>
<h2 id="二、FactoryBean"><a href="#二、FactoryBean" class="headerlink" title="二、FactoryBean"></a>二、FactoryBean</h2><p>首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p>
<h3 id="2-1-源码"><a href="#2-1-源码" class="headerlink" title="2.1 源码"></a>2.1 源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//从工厂中获取bean</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="comment">//获取Bean工厂创建的对象的类型</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line">	<span class="comment">//Bean工厂创建的对象是否是单例模式</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从它定义的接口可以看出，<code>FactoryBean</code>表现的是一个工厂的职责。 <strong>即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用<code>getObject()</code>返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上’<code>&amp;</code>‘符号。</strong></p>
<ul>
<li>getObject(‘name’)返回工厂中的实例</li>
<li>getObject(‘&amp;name’)返回工厂本身的实例</li>
</ul>
<p>通常情况下，bean 无须自己实现工厂模式，Spring 容器担任了工厂的 角色；但少数情况下，容器中的 bean 本身就是工厂，作用是产生其他 bean 实例。由工厂 bean 产生的其他 bean 实例，不再由 Spring 容器产生，因此与普通 bean 的配置不同，不再需要提供 class 元素。</p>
<h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><p>先定义一个Bean实现FactoryBean接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = <span class="string">"通过构造方法初始化实例"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 这里并不一定要返回MyBean自身的实例，可以是其他任何对象的实例。</span></span><br><span class="line">        <span class="comment">//如return new Student()...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean(<span class="string">"通过FactoryBean.getObject()创建实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyBean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyBean实现了FactoryBean接口的两个方法，getObject()是可以返回任何对象的实例的，这里测试就返回MyBean自身实例，且返回前给message字段赋值。同时在构造方法中也为message赋值。然后测试代码中先通过名称获取Bean实例，打印message的内容，再通过<code>&amp;+名称</code>获取实例并打印message内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= TestApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">FactoryBeanTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyBean myBean1 = (MyBean) context.getBean(<span class="string">"myBean"</span>);</span><br><span class="line">        System.out.println(<span class="string">"myBean1 = "</span> + myBean1.getMessage());</span><br><span class="line">        MyBean myBean2 = (MyBean) context.getBean(<span class="string">"&amp;myBean"</span>);</span><br><span class="line">        System.out.println(<span class="string">"myBean2 = "</span> + myBean2.getMessage());</span><br><span class="line">        System.out.println(<span class="string">"myBean1.equals(myBean2) = "</span> + myBean1.equals(myBean2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myBean1 = 通过FactoryBean.getObject()初始化实例</span><br><span class="line">myBean2 = 通过构造方法初始化实例</span><br><span class="line">myBean1.equals(myBean2) = <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-使用场景"><a href="#2-3-使用场景" class="headerlink" title="2.3 使用场景"></a>2.3 使用场景</h3><p>说了这么多，为什么要有<code>FactoryBean</code>这个东西呢，有什么具体的作用吗？<br>FactoryBean在Spring中最为典型的一个应用就是用来<strong>创建AOP的代理对象</strong>。</p>
<p>我们知道AOP实际上是Spring在运行时创建了一个代理对象，也就是说这个对象，是我们在运行时创建的，而不是一开始就定义好的，这很符合工厂方法模式。更形象地说，AOP代理对象通过Java的反射机制，在运行时创建了一个代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在Spring中就是——<code>ProxyFactoryBean</code>。</p>
<p>所以，FactoryBean为我们实例化Bean提供了一个更为灵活的方式，我们可以通过FactoryBean创建出更为复杂的Bean实例。</p>
<h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><ul>
<li>他们两个都是个工厂，但<code>FactoryBean</code>本质上还是一个Bean，也归<code>BeanFactory</code>管理</li>
<li><code>BeanFactory</code>是Spring容器的顶层接口，<code>FactoryBean</code>更类似于用户自定义的工厂接口。</li>
</ul>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p><code>BeanFactory</code>与<code>FactoryBean</code>的区别确实容易混淆，死记硬背是不行的，最好还是从源码层面，置于spring的环境中去理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/14/factoryBean%E5%92%8CbeanFactory/" data-id="cka6efimo0000k4ughenp092e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-45-跳跃游戏II" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/04/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/" class="article-date">
  <time datetime="2020-05-04T01:20:18.000Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/04/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/">45-跳跃游戏II</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>示例:</p>
<blockquote>
<p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/jump-game-ii" target="_blank" rel="noopener">传送门</a></p>
<h3 id="分析一下"><a href="#分析一下" class="headerlink" title="分析一下"></a>分析一下</h3><p><strong>贪心策略：每次选择下一跳最远的点。</strong></p>
<p>参数解释：</p>
<blockquote>
<p>steps：记录总跳数。</p>
<p>end：第steps跳跃的选择确定以后，能达到的最远边界。</p>
<p>max：记录从当前点能跳跃的最远距离</p>
<p>if( i == end )：每次当i走到end，也就是上一个steps能到达的最远边界的时候，更新end。也就是对上以steps能到达的所有点遍历了一遍，选出最远的点。</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>; <span class="comment">// 记录的是当前能跳到边界</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>; <span class="comment">// 记录在边界(end)中的点能跳到的最远距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            max = Math.max(max, i + nums[i]);</span><br><span class="line">            <span class="comment">// 只有当i == end才更新一次，</span></span><br><span class="line">            <span class="comment">// 当i==end 意味着max中存储了，这一次选择所有可能的点的最远跳跃距离</span></span><br><span class="line">            <span class="keyword">if</span>( i == end)&#123; <span class="comment">//遇到边界，就更新边界，并且步数加一</span></span><br><span class="line">                end = max;</span><br><span class="line">                steps++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/04/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/" data-id="ck9rt58410000n8ug1n29h9rz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-一条SQL更新语句是如何执行的" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/" class="article-date">
  <time datetime="2020-05-03T11:20:58.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/">日志系统：一条SQL更新语句是如何执行的?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>文章来源：<a href="https://time.geekbang.org/column/intro/139" target="_blank" rel="noopener">MySQL实战45讲</a></p>
<p>这门课很好，90块钱物超所值。支持大家购买正版。</p>
</blockquote>
<p>现有一个表</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br></pre></td></tr></table></figure>

<p>如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>

<p>更新语句和之前的查询语句一样，都是下图这个流程：</p>
<img src="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class title="Mysql逻辑架构图">

<p>你执行语句前要先连接数据库，这是连接器的工作。</p>
<p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p>
<p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p>
<p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触 MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log 和 binlog 在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。</p>
<h2 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h2><p>这里有一个形象的比喻：</p>
<p>《孔乙己》中的掌柜老板有一个<strong>粉板</strong>，用于记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的<strong>账本</strong>。</p>
<p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p>
<ul>
<li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li>
<li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li>
</ul>
<p>如果店里生意很忙，掌柜肯定是选择的第二种方式，因为前者操作太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p>
<p>同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p>
<p>而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 <strong>WAL</strong> 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p>
<p><strong>具体来说</strong>，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 <strong>redo log(粉板)</strong>里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到<strong>磁盘(账本)</strong>里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p>
<p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p>
<p>与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>
<img src="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/2.png" class title="redo_log写入">

<p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe。</strong></p>
<p>要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p>
<h2 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/" data-id="ck9r73has0000dsugdeix9dzt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-一条SQL查询语句是如何执行的" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/" class="article-date">
  <time datetime="2020-05-03T08:44:23.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/">基础架构：一条SQL查询语句是如何执行的?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>文章来源：<a href="https://time.geekbang.org/column/intro/139" target="_blank" rel="noopener">MySQL实战45讲</a></p>
<p>这门课很好，90块钱物超所值。支持大家购买正版。</p>
</blockquote>
<p>我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个 ID 字段，在执行下面这个查询语句时：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10；</span><br></pre></td></tr></table></figure>

<p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。</p>
<p>下面我给出的是 MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。</p>
<img src="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class title="Mysql逻辑架构图">

<p>大体来说，MySQL 可以分为 <strong>Server 层</strong> 和<strong>存储引擎层</strong>两部分。</p>
<p><strong>Server 层</strong>包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>而<strong>存储引擎层</strong>负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>
<p>从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。</p>
<h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，<strong>连接器负责跟客户端建立连接、获取权限、维持和管理连接</strong>。连接命令一般是这么写的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h<span class="variable">$ip</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> -p</span><br></pre></td></tr></table></figure>

<p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>
<ul>
<li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li>
<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li>
</ul>
<p>一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。需要使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>
<img src="/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/show-processlist.png" class title="show-processlist">

<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout</code> 控制的，<strong>默认值是 8 小时</strong>。</p>
<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
<ul>
<li><p><strong>长连接:</strong>连接成功后，如果客户端持续有请求，则一直使用同一个连接。</p>
</li>
<li><p><strong>短连接</strong>则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>
</li>
</ul>
<p>建立连接的过程通常是比较复杂的，<strong>尽量使用长连接</strong>。</p>
<p>但是全部使用长连接后，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>
<p>怎么解决这个问题呢？你可以考虑以下<strong>两种方案</strong>。</p>
<ol>
<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>
<li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>
</ol>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。</p>
<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>
<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。</p>
<p>需要注意的是，<strong>MySQL 8.0 版本直接将查询缓存的整块功能删掉了</strong>，也就是说 8.0 开始彻底没有这个功能了。</p>
<h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>分析器先会做<strong>“词法分析”</strong>。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p>
<p>做完了这些识别以后，就要做<strong>“语法分析”</strong>。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p>
<p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID=1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; <span class="keyword">check</span> the <span class="keyword">manual</span> that corresponds <span class="keyword">to</span> your MySQL <span class="keyword">server</span> <span class="keyword">version</span> <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> <span class="keyword">use</span> near <span class="string">'elect * from t where ID=1'</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure>

<ul>
<li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li>
<li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li>
</ul>
<p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>
<h3 id="权限的拦截是在执行器上判断的"><a href="#权限的拦截是在执行器上判断的" class="headerlink" title="权限的拦截是在执行器上判断的"></a>权限的拦截是在执行器上判断的</h3><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): <span class="keyword">SELECT</span> command denied <span class="keyword">to</span> <span class="keyword">user</span> <span class="string">'b'</span>@<span class="string">'localhost'</span> <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">'T'</span></span><br></pre></td></tr></table></figure>

<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，<strong>去使用这个引擎提供的接口。</strong></p>
<p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>
<ul>
<li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ul>
<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>
<p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>
<p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟 rows_examined 并不是完全相同的。</strong>我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天我给你介绍了 MySQL 的逻辑架构，希望你对一个 SQL 语句完整执行流程的各个阶段有了一个初步的印象。由于篇幅的限制，我只是用一个查询的例子将各个环节过了一遍。如果你还对每个环节的展开细节存有疑问，也不用担心，后续在实战章节中我还会再提到它们。</p>
<h2 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h2><p>如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p>
<h3 id="问题解答："><a href="#问题解答：" class="headerlink" title="问题解答："></a>问题解答：</h3><p><strong>答案是：优化器</strong>，有评论提到：</p>
<p>《高性能mysql》里提到解析器和预处理器。</p>
<p>解析器处理语法和解析查询, 生成一课对应的解析树。</p>
<p>预处理器进一步检查解析树的合法。比如: 数据表和数据列是否存在, 别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器。</p>
<p>所以我觉得课后习题的错误应该发生在在分析器处理阶段&gt;_&lt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/03/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/" data-id="ck9r73haw0001dsug3a78fmce" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spring模块划分" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/01/spring%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86/" class="article-date">
  <time datetime="2020-05-01T06:09:09.000Z" itemprop="datePublished">2020-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/01/spring%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86/">spring-framework模块划分</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a href="https://github.com/spring-projects/spring-framework">spring-frame官方仓库</a></p>
<p><a href="https://spring.io/" target="_blank" rel="noopener">spring官网</a></p>
<p><a href="https://www.cnblogs.com/MrZhouZ/p/11530578.html" target="_blank" rel="noopener">Spring框架的前世今生与系统架构</a></p>
</blockquote>
<h2 id="spring-framework总览"><a href="#spring-framework总览" class="headerlink" title="spring-framework总览"></a>spring-framework总览</h2><p>spring-framework官方仓库中把spring的一些功能进行了拆解，分在不同模块中。这里就简单总结一下每个模块的作用，对spring-framework有一个总体上的认识。</p>
<p>首先来看一下spring-framework的整个架构：</p>
<img src="/2020/05/01/spring%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86/1.png" class title="spring-framework模块">



<p>可以看到官方仓库把spring-framework分成了21个模块，让开发者可以按需引入。</p>
<img src="/2020/05/01/spring%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86/2.png" class title="spring-framework模块">



<h2 id="分模块简介"><a href="#分模块简介" class="headerlink" title="分模块简介"></a>分模块简介</h2><p>接下来对各个模块进行一些最简单的介绍</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>模块名</th>
<th>作用简介</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>spring-aop</td>
<td>给spring-frame提供aop的支持，也就是面向切面的编程的能力。</td>
</tr>
<tr>
<td>2</td>
<td>spring-aspects</td>
<td>spring-aspects 模块集成自 AspectJ 框架，主要是为 Spring AOP 提供多种 AOP 实现方法。</td>
</tr>
<tr>
<td>3</td>
<td>spring-beans</td>
<td><strong>核心模块</strong>。beans包的核心功能就是对Bean对象生命周期的管理，包含Bean的定义、解析和创建等。</td>
</tr>
<tr>
<td>4</td>
<td>spring-context-indexer</td>
<td>spring-context-indexer 模块是 Spring 的类管理组件和 Classpath 扫描。</td>
</tr>
<tr>
<td>5</td>
<td>spring-context-support</td>
<td>spring-context-support 模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器。</td>
</tr>
<tr>
<td>6</td>
<td>spring-context</td>
<td><strong>核心模块</strong>。spring-context 模块构架于核心模块之上，扩展了 BeanFactory，为她添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。</td>
</tr>
<tr>
<td>7</td>
<td>spring-core</td>
<td><strong>核心模块</strong>。core模块的功能实现的反向控制与依赖注入、Bean配置与加载。</td>
</tr>
<tr>
<td>8</td>
<td>spring-expression</td>
<td><strong>核心模块</strong>。又称SpEL，spring-expression 模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等。</td>
</tr>
<tr>
<td>9</td>
<td>spring-instrument</td>
<td>spring-instrument 模块是基于 JAVA SE 中的”java.lang.instrument”进行设计的，应该算是 AOP的一个支援模块。</td>
</tr>
<tr>
<td>10</td>
<td>spring-jcl</td>
<td>spring-jcl模这个模块是spring源码里最基础的模块没有依赖其他模块，它是为了兼容不同版本的日志系统。</td>
</tr>
<tr>
<td>11</td>
<td>spring-jdbc</td>
<td>spring-jdbc 模块是 Spring 提供的 JDBC 抽象框架的主要实现模块，用于简化 Spring JDBC 操作 。</td>
</tr>
<tr>
<td>12</td>
<td>spring-jms</td>
<td>spring-jms 模块（Java Messaging Service）能够发送和接收信息。</td>
</tr>
<tr>
<td>13</td>
<td>spring-messaging</td>
<td>即 spring-messaging 模块，是从 Spring4 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</td>
</tr>
<tr>
<td>14</td>
<td>spring-orm</td>
<td>spring-orm 模块是 ORM 框架支持模块，主要集成 Hibernate, Java Persistence API (JPA) 和Java Data Objects (JDO) 用于资源管理、数据访问对象(DAO)的实现和事务策略。</td>
</tr>
<tr>
<td>15</td>
<td>spring-oxm</td>
<td>spring-oxm 模块主要提供一个抽象层以支撑 OXM（OXM 是 Object-to-XML-Mapping 的缩写，它是一个 O/M-mapper，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象）</td>
</tr>
<tr>
<td>16</td>
<td>spring-test</td>
<td>spring-test 模块，主要为测试提供支持的。</td>
</tr>
<tr>
<td>17</td>
<td>spring-tx</td>
<td>spring-tx 模块是 Spring JDBC 事务控制实现模块。</td>
</tr>
<tr>
<td>18</td>
<td>spring-web</td>
<td>spring-web 模块为 Spring 提供了最基础 Web 支持。</td>
</tr>
<tr>
<td>19</td>
<td>spring-webflux</td>
<td>spring-webflux 是一个新的非堵塞函数式 Reactive Web 框架。</td>
</tr>
<tr>
<td>20</td>
<td>spring-webmvc</td>
<td>spring-webmvc 模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC。</td>
</tr>
<tr>
<td>21</td>
<td>spring-webscoket</td>
<td>spring-websocket 模块主要是与 Web 前端的全双工通讯的协议。</td>
</tr>
</tbody></table>
<h2 id="模块间的配合"><a href="#模块间的配合" class="headerlink" title="模块间的配合"></a>模块间的配合</h2><p>回顾一下上面的架构图</p>
<img src="/2020/05/01/spring%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86/1.png" class title="spring-frame模块">

<h3 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h3><p>由spring-beans、spring-core、spring-context和spring-expression（Spring Expression Language,SpEL） 4 个模块组成。</p>
<p><strong>spring-core</strong> 和 spring-beans 模块是 Spring 框架的核心模块，包含了控制反转（Inversion of Control, IOC）和依赖注入（Dependency Injection, DI）。BeanFactory 接口是 Spring 框架中的核心接口，它是工厂模式的具体实现。BeanFactory 使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。但 BeanFactory 容器实例化后并不会自动实例化 Bean，只有当 Bean 被使用时 BeanFactory 容器才会对该 Bean 进行实例化与依赖关系的装配。</p>
<p><strong>spring-context</strong> 模块构架于核心模块之上，他扩展了 BeanFactory，为她添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。此外该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext 是该模块的核心接口，她的超类是 BeanFactory。与BeanFactory 不同，pplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态。</p>
<p><strong>spring-context-support</strong> 模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器。spring-context-indexer 模块是 Spring 的类管理组件和 Classpath 扫描。</p>
<p><strong>spring-expression</strong>模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等。它的语法类似于传统 EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。这种语言的特性是基于 Spring 产品的需求而设计，他可以非常方便地同 Spring IOC 进行交互。 </p>
<h3 id="AOP和设备支持"><a href="#AOP和设备支持" class="headerlink" title="AOP和设备支持"></a>AOP和设备支持</h3><p>由 spring-aop、spring-aspects 和 spring-instrument 3 个模块组成。</p>
<p><strong>spring-aop</strong> 是 Spring 的另一个核心模块，是 AOP 主要的实现模块。作为继 OOP 后，对程序员影响最大的编程思想之一，AOP 极大地开拓了人们对于编程的思路。在 Spring 中，他是以 JVM 的动态代理技术为基础，然后设计出了一系列的 AOP 横切实现，比如前置通知、返回通知、异常通知等，同时，Pointcut 接口来匹配切入点，可以使用现有的切入点来设计横切面，也可以扩展相关方法根据需求进行切入。</p>
<p><strong>spring-aspects</strong> 模块集成自 AspectJ 框架，主要是为 Spring AOP 提供多种 AOP 实现方法。</p>
<p><strong>spring-instrument</strong>模块是基于 JAVA SE 中的”java.lang.instrument”进行设计的，应该算是 AOP的一个支援模块，主要作用是在 JVM 启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现 AOP 的功能。在分类里，我把他分在了 AOP 模块下，在 Spring 官方文档里对这个地方也有点含糊不清，这里是纯个人观点。</p>
<h3 id="数据访问与集成"><a href="#数据访问与集成" class="headerlink" title="数据访问与集成"></a>数据访问与集成</h3><p>由 spring-jdbc、spring-tx、spring-orm、spring-jms 和 spring-oxm 5 个模块组成。</p>
<p><strong>spring-jdbc</strong> 模块是 Spring 提供的 JDBC 抽象框架的主要实现模块，用于简化 Spring JDBC 操作 。主要是提供 JDBC 模板方式、关系数据库对象化方式、SimpleJdbc 方式、事务管理来简化 JDBC 编程，主要实现类是 JdbcTemplate、SimpleJdbcTemplate 以及 NamedParameterJdbcTemplate。</p>
<p><strong>spring-tx</strong> 模块是 Spring JDBC 事务控制实现模块。使用 Spring 框架，它对事务做了很好的封装，通过它的 AOP 配置，可以灵活的配置在任何一层；但是在很多的需求和应用，直接使用 JDBC 事务控制还是有其优势的。其实，事务是以业务逻辑为基础的；一个完整的业务应该对应业务层里的一个方法；如果业务操作失败，则整个事务回滚；所以，事务控制是绝对应该放在业务层的；但是，持久层的设计则应该遵循一个很重要的原则：保证操作的原子性，即持久层里的每个方法都应该是不可以分割的。所以，在使用 Spring JDBC 事务控制时，应该注意其特殊性。</p>
<p><strong>spring-orm</strong>模块是 ORM 框架支持模块，主要集成 Hibernate, Java Persistence API (JPA) 和Java Data Objects (JDO) 用于资源管理、数据访问对象(DAO)的实现和事务策略。</p>
<p><strong>spring-oxm</strong> 模块主要提供一个抽象层以支撑 OXM（OXM 是 Object-to-XML-Mapping 的缩写，它是一个 O/M-mapper，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象），例如：JAXB, Castor, XMLBeans, JiBX 和 XStream 等。</p>
<p><strong>spring-jms</strong>模块（Java Messaging Service）能够发送和接收信息，自 Spring Framework 4.1 以后，他还提供了对 spring-messaging 模块的支撑。 </p>
<h3 id="Web组件"><a href="#Web组件" class="headerlink" title="Web组件"></a>Web组件</h3><p>由 spring-web、spring-webmvc、spring-websocket 和 spring-webflux 4 个模块组成。</p>
<p><strong>spring-web</strong>模块为 Spring 提供了最基础 Web 支持，主要建立于核心容器之上，通过 Servlet 或者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持。</p>
<p><strong>spring-webmvc</strong>模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC（model-view-Controller）的 Web 应用。</p>
<p><strong>spring-websocket</strong>模块主要是与 Web 前端的全双工通讯的协议。</p>
<p><strong>spring-webflux</strong>是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。 </p>
<h3 id="通信报文"><a href="#通信报文" class="headerlink" title="通信报文"></a>通信报文</h3><p><strong>spring-messaging</strong> 模块，是从 Spring4 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。 </p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p><strong>spring-test</strong> 模块，主要为测试提供支持的，毕竟在不需要发布（程序）到你的应用服务器或者连接到其他企业设施的情况下能够执行一些集成测试或者其他测试对于任何企业都是非常重要的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/05/01/spring%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86/" data-id="ck9qswfqq001y2cugffoa37u1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-index-concept" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/28/mysql-index-concept/" class="article-date">
  <time datetime="2020-04-28T12:48:10.000Z" itemprop="datePublished">2020-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/mysql-index-concept/">聚集索引&amp;非聚集索引&amp;覆盖索引总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-索引简介"><a href="#一-索引简介" class="headerlink" title="一.索引简介"></a>一.索引简介</h2><p>众所周知，索引是关系型数据库中给数据库表中一列或多列的值排序后的存储结构，SQL的主流索引结构有B+树以及Hash结构，聚集索引以及非聚集索引用的是B+树索引。这篇文章会总结MySQL的InnoDB和MyISAM两种引擎的索引。</p>
<h2 id="二-聚集索引"><a href="#二-聚集索引" class="headerlink" title="二.聚集索引"></a>二.聚集索引</h2><p>聚集（clustered）索引，也叫聚簇索引。</p>
<blockquote>
<p>定义：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。</p>
</blockquote>
<p>单单从定义来看是不是显得有点抽象，打个比方，一个表就像是我们以前用的新华字典，聚集索引就像是拼音目录，而每个字存放的页码就是我们的数据物理地址，我们如果要查询一个“哇”字，我们只需要查询“哇”字对应在新华字典拼音目录对应的页码，就可以查询到对应的“哇”字所在的位置，而拼音目录对应的A-Z的字顺序，和新华字典实际存储的字的顺序A-Z也是一样的，如果我们中文新出了一个字，拼音开头第一个是B，那么他插入的时候也要按照拼音目录顺序插入到A字的后面，现在用一个简单的示意图来大概说明一下在数据库中的样子：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>id</th>
<th>username</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>0x01</td>
<td>1</td>
<td>小明</td>
<td>90</td>
</tr>
<tr>
<td>0x02</td>
<td>2</td>
<td>小红</td>
<td>80</td>
</tr>
<tr>
<td>0x03</td>
<td>3</td>
<td>小华</td>
<td>92</td>
</tr>
<tr>
<td>..</td>
<td>..</td>
<td>..</td>
<td>..</td>
</tr>
<tr>
<td>0xff</td>
<td>256</td>
<td>小英</td>
<td>70</td>
</tr>
</tbody></table>
<p>注：第一列的地址表示该行数据在磁盘中的物理地址，后面三列才是我们SQL里面用的表里的列，其中id是主键，建立了聚集索引。</p>
<p>结合上面的表格就可以理解这句话了吧：数据行的物理顺序与列值的<strong>顺序相同</strong>，如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后。而且由于物理排列方式与聚集索引的顺序相同，所以也就只能建立一个聚集索引了。</p>
<img src="/2020/04/28/mysql-index-concept/1.png" class title="ss">

<p><strong>聚集索引实际存放的示意图</strong></p>
<p>从上图可以看出聚集索引的好处了，索引的叶子节点就是对应的数据节点（MySQL的MyISAM除外，此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别），可以直接获取到对应的全部列的数据，而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询，后面会详细讲。因此在查询方面，聚集索引的速度往往会更占优势。</p>
<h3 id="创建聚集索引"><a href="#创建聚集索引" class="headerlink" title="创建聚集索引"></a>创建聚集索引</h3><p>如果不创建索引，系统会自动创建一个隐含列作为表的聚集索引。</p>
<ol>
<li><p>创建表的时候指定主键（注意：SQL Sever默认主键为聚集索引，也可以指定为非聚集索引，而MySQL里主键就是聚集索引）</p>
</li>
<li><p>创建表后添加聚集索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> primary <span class="keyword">key</span>(colum_name)</span><br></pre></td></tr></table></figure>

<p>值得注意的是，最好还是在创建表的时候添加聚集索引，由于聚集索引的物理顺序上的特殊性，因此如果再在上面创建索引的时候会根据索引列的排序移动全部数据行上面的顺序，会非常地耗费时间以及性能。</p>
</li>
</ol>
<h2 id="三-非聚集索引"><a href="#三-非聚集索引" class="headerlink" title="三.非聚集索引"></a>三.非聚集索引</h2><p>非聚集（unclustered）索引。</p>
<blockquote>
<p>定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。</p>
</blockquote>
<p>其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成<strong>普通索引</strong>，<strong>唯一索引</strong>，<strong>全文索引</strong>。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的偏旁字典，他结构顺序与实际存放顺序不一定一致。</p>
<img src="/2020/04/28/mysql-index-concept/2.png" class title="ss">

<h3 id="非聚集索引的二次查询问题"><a href="#非聚集索引的二次查询问题" class="headerlink" title="非聚集索引的二次查询问题"></a>非聚集索引的二次查询问题</h3><p>非聚集索引叶节点仍然是索引节点，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据。</p>
<p>如有以下表t1：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>username</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>小明</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>小红</td>
<td>80</td>
</tr>
<tr>
<td>3</td>
<td>小华</td>
<td>92</td>
</tr>
<tr>
<td>..</td>
<td>..</td>
<td>..</td>
</tr>
<tr>
<td>256</td>
<td>小英</td>
<td>70</td>
</tr>
</tbody></table>
<p>以及聚集索引clustered index(id), 非聚集索引<strong>index(username)</strong>。</p>
<p>使用以下语句进行查询，不需要进行二次查询，直接就可以从非聚集索引的节点里面就可以获取到查询列的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, username <span class="keyword">from</span> t1 <span class="keyword">where</span> username = <span class="string">'小明'</span></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> t1 <span class="keyword">where</span> username = <span class="string">'小明'</span></span><br></pre></td></tr></table></figure>

<p>但是使用以下语句进行查询，就需要二次的查询去获取原数据行的score：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username, score <span class="keyword">from</span> t1 <span class="keyword">where</span> username = <span class="string">'小明'</span></span><br></pre></td></tr></table></figure>

<p><strong>原因是score不在索引中，所以得回表查询。</strong></p>
<h3 id="解决办法：覆盖索引"><a href="#解决办法：覆盖索引" class="headerlink" title="解决办法：覆盖索引"></a>解决办法：覆盖索引</h3><blockquote>
<p>如果查询的内容（select col1, col2），col1和col2都在索引中，那就不用回表了。满足这个条件就叫覆盖索引。</p>
</blockquote>
<p>要注意使用复合索引需要满足最左侧索引的原则，也就是查询的时候如果where条件里面没有最左边的一到多列，索引就不会起作用。</p>
<p>在SQL Server中还有include的用法，可以把非聚集索引里包含的列包含进来，而不一定需要建立复合索引。</p>
<h2 id="四-总结与使用心得"><a href="#四-总结与使用心得" class="headerlink" title="四.总结与使用心得"></a>四.总结与使用心得</h2><ol>
<li>使用聚集索引的查询效率要比非聚集索引的效率要高，但是如果需要频繁去改变聚集索引的值，写入性能并不高，因为需要移动对应数据的物理位置。</li>
<li>非聚集索引在查询的时候可以的话就避免二次查询，这样性能会大幅提升。</li>
<li>不是所有的表都适合建立索引，只有数据量大表才适合建立索引，且建立在选择性高的列上面性能会更好。</li>
</ol>
<blockquote>
<p>文章来源：<a href="https://www.cnblogs.com/s-b-b/p/8334593.html" target="_blank" rel="noopener">[聚集索引与非聚集索引的总结]</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/04/28/mysql-index-concept/" data-id="ck9qswfqo001q2cug5q2nd82r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-config" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/28/mysql-config/" class="article-date">
  <time datetime="2020-04-28T11:48:51.000Z" itemprop="datePublished">2020-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/mysql-config/">Mysql5.6&amp;5.7配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>MySQL 5.6 &amp; 5.7 最优配置模板</strong></p>
<p>Inside 君整理了一份最新基于 MySQL 5.6 和 5.7 的配置文件模板，基本上可以说覆盖 90% 的调优选项，用户只需根据自己的服务器配置稍作修改即可，如 InnoDB 缓冲池的大小、IO 能力（innodb_buffer_pool_size，innodb_io_capacity）。特别注意，这份配置文件不用修改，可以直接运行在 MySQL 5.6 和 5.7 的版本下，这里使用了小小的技巧，具体可看配置文件。如果配置参数存在问题，也可以及时反馈 Inside 君，我们一起成长。</p>
<p>触发 Inside 君做这件事情的原因是大部分网络上的 MySQL 配置文件都非常非常古老，大多都是基于 MySQL 5.1 的版本，这导致了绝大部分 MySQL 并没有运行在最优的环境，从而导致一些错误的使用，亦或是灾难性事故的发生，比如数据丢失，主从数据不一致等。而这些问题早在 5.6 版本及以后的版本中得到了解决。</p>
<p>最后，抛弃你那所谓的、陈旧的、错误的 MySQL 配置文件，面向一个崭新的高性能、高可靠、高可扩展 MySQL 时代，你要做的就是下载这份配置文件并用于你的生产环境。</p>
<p>insidemysql_my.cnf：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">user&#x3D;david</span><br><span class="line">password&#x3D;88888888</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">########basic settings########</span><br><span class="line">server-id &#x3D; 11 </span><br><span class="line">port &#x3D; 3306</span><br><span class="line">user &#x3D; mysql</span><br><span class="line">bind_address &#x3D; 10.166.224.32</span><br><span class="line">autocommit &#x3D; 0</span><br><span class="line">character_set_server&#x3D;utf8mb4</span><br><span class="line">skip_name_resolve &#x3D; 1</span><br><span class="line">max_connections &#x3D; 800</span><br><span class="line">max_connect_errors &#x3D; 1000</span><br><span class="line">datadir &#x3D; &#x2F;data&#x2F;mysql_data</span><br><span class="line">transaction_isolation &#x3D; READ-COMMITTED</span><br><span class="line">explicit_defaults_for_timestamp &#x3D; 1</span><br><span class="line">join_buffer_size &#x3D; 134217728</span><br><span class="line">tmp_table_size &#x3D; 67108864</span><br><span class="line">tmpdir &#x3D; &#x2F;tmp</span><br><span class="line">max_allowed_packet &#x3D; 16777216</span><br><span class="line">sql_mode &#x3D; &quot;STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER&quot;</span><br><span class="line">interactive_timeout &#x3D; 1800</span><br><span class="line">wait_timeout &#x3D; 1800</span><br><span class="line">read_buffer_size &#x3D; 16777216</span><br><span class="line">read_rnd_buffer_size &#x3D; 33554432</span><br><span class="line">sort_buffer_size &#x3D; 33554432</span><br><span class="line">########log settings########</span><br><span class="line">log_error &#x3D; error.log</span><br><span class="line">slow_query_log &#x3D; 1</span><br><span class="line">slow_query_log_file &#x3D; slow.log</span><br><span class="line">log_queries_not_using_indexes &#x3D; 1</span><br><span class="line">log_slow_admin_statements &#x3D; 1</span><br><span class="line">log_slow_slave_statements &#x3D; 1</span><br><span class="line">log_throttle_queries_not_using_indexes &#x3D; 10</span><br><span class="line">expire_logs_days &#x3D; 90</span><br><span class="line">long_query_time &#x3D; 2</span><br><span class="line">min_examined_row_limit &#x3D; 100</span><br><span class="line">########replication settings########</span><br><span class="line">master_info_repository &#x3D; TABLE</span><br><span class="line">relay_log_info_repository &#x3D; TABLE</span><br><span class="line">log_bin &#x3D; bin.log</span><br><span class="line">sync_binlog &#x3D; 1</span><br><span class="line">gtid_mode &#x3D; on</span><br><span class="line">enforce_gtid_consistency &#x3D; 1</span><br><span class="line">log_slave_updates</span><br><span class="line">binlog_format &#x3D; row </span><br><span class="line">relay_log &#x3D; relay.log</span><br><span class="line">relay_log_recovery &#x3D; 1</span><br><span class="line">binlog_gtid_simple_recovery &#x3D; 1</span><br><span class="line">slave_skip_errors &#x3D; ddl_exist_errors</span><br><span class="line">########innodb settings########</span><br><span class="line">innodb_page_size &#x3D; 8192</span><br><span class="line">innodb_buffer_pool_size &#x3D; 6G</span><br><span class="line">innodb_buffer_pool_instances &#x3D; 8</span><br><span class="line">innodb_buffer_pool_load_at_startup &#x3D; 1</span><br><span class="line">innodb_buffer_pool_dump_at_shutdown &#x3D; 1</span><br><span class="line">innodb_lru_scan_depth &#x3D; 2000</span><br><span class="line">innodb_lock_wait_timeout &#x3D; 5</span><br><span class="line">innodb_io_capacity &#x3D; 4000</span><br><span class="line">innodb_io_capacity_max &#x3D; 8000</span><br><span class="line">innodb_flush_method &#x3D; O_DIRECT</span><br><span class="line">innodb_file_format &#x3D; Barracuda</span><br><span class="line">innodb_file_format_max &#x3D; Barracuda</span><br><span class="line">innodb_log_group_home_dir &#x3D; &#x2F;redolog&#x2F;</span><br><span class="line">innodb_undo_directory &#x3D; &#x2F;undolog&#x2F;</span><br><span class="line">innodb_undo_logs &#x3D; 128</span><br><span class="line">innodb_undo_tablespaces &#x3D; 3</span><br><span class="line">innodb_flush_neighbors &#x3D; 1</span><br><span class="line">innodb_log_file_size &#x3D; 4G</span><br><span class="line">innodb_log_buffer_size &#x3D; 16777216</span><br><span class="line">innodb_purge_threads &#x3D; 4</span><br><span class="line">innodb_large_prefix &#x3D; 1</span><br><span class="line">innodb_thread_concurrency &#x3D; 64</span><br><span class="line">innodb_print_all_deadlocks &#x3D; 1</span><br><span class="line">innodb_strict_mode &#x3D; 1</span><br><span class="line">innodb_sort_buffer_size &#x3D; 67108864 </span><br><span class="line">########semi sync replication settings########</span><br><span class="line">plugin_dir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;lib&#x2F;plugin</span><br><span class="line">plugin_load &#x3D; &quot;rpl_semi_sync_master&#x3D;semisync_master.so;rpl_semi_sync_slave&#x3D;semisync_slave.so&quot;</span><br><span class="line">loose_rpl_semi_sync_master_enabled &#x3D; 1</span><br><span class="line">loose_rpl_semi_sync_slave_enabled &#x3D; 1</span><br><span class="line">loose_rpl_semi_sync_master_timeout &#x3D; 5000</span><br><span class="line"></span><br><span class="line">[mysqld-5.7]</span><br><span class="line">innodb_buffer_pool_dump_pct &#x3D; 40</span><br><span class="line">innodb_page_cleaners &#x3D; 4</span><br><span class="line">innodb_undo_log_truncate &#x3D; 1</span><br><span class="line">innodb_max_undo_log_size &#x3D; 2G</span><br><span class="line">innodb_purge_rseg_truncate_frequency &#x3D; 128</span><br><span class="line">binlog_gtid_simple_recovery&#x3D;1</span><br><span class="line">log_timestamps&#x3D;system</span><br><span class="line">transaction_write_set_extraction&#x3D;MURMUR32</span><br><span class="line">show_compatibility_56&#x3D;on</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作者：殷建卫</p>
<p>链接：<a href="https://www.yuque.com/yinjianwei/vyrvkf/tb8uaw" target="_blank" rel="noopener">https://www.yuque.com/yinjianwei/vyrvkf/tb8uaw</a></p>
<p>来源：<a href="https://www.yuque.com/yinjianwei/vyrvkf" target="_blank" rel="noopener">殷建卫 - 架构笔记</a></p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/04/28/mysql-config/" data-id="ck9qswfqi001b2cug9762814v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Mysql-rules" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/28/Mysql-rules/" class="article-date">
  <time datetime="2020-04-28T11:42:50.000Z" itemprop="datePublished">2020-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/Mysql-rules/">MySQL 使用规定</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>MySQL 军规</strong></p>
<blockquote>
<p>参考：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959906&idx=1&sn=2cbdc66cfb5b53cf4327a1e0d18d9b4a&chksm=bd2d07be8a5a8ea86dc3c04eced3f411ee5ec207f73d317245e1fefea1628feb037ad71531bc&scene=27#wechat_redirect" target="_blank" rel="noopener">《58到家数据库30条军规解读》</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961030&idx=1&sn=73a04dabca409c1557e752382d777181&chksm=bd2d031a8a5a8a0c6f7b58b79ae8933dfefbd840dfb5d34a5c708ab63e6decbbc1b13533ebc8&scene=27#wechat_redirect" target="_blank" rel="noopener">《58到家MySQL军规升级版》</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651960775&idx=1&sn=1a9c9f4b94dfe71ad2528fb2c84f5ec7&chksm=bd2d001b8a5a890d302d139ea42e9ffde44407738a618865934e40b8e35486b13cafca2933f6&scene=27#wechat_redirect" target="_blank" rel="noopener">《赶集mysql军规》</a></p>
</blockquote>
<h3 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h3><table>
<thead>
<tr>
<th><strong>必须使用 InnoDB 存储引擎</strong>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>表字符集默认使用</strong> <strong>utf8</strong>，必要时候使用<strong>utf8mb4</strong><br>解读：万国码，无需转码，无乱码风险，节省空间，utf8mb4 是 utf8 的超集，有存储4字节例如表情符号时，使用它。</td>
</tr>
<tr>
<td><strong>数据表、数据字段必须加入中文注释</strong></td>
</tr>
<tr>
<td><strong>禁止使用存储过程、视图、触发器、Event</strong><br>解读：高并发大数据的互联网业务，架构设计思路是“解放数据库 CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU 计算还是上移吧。</td>
</tr>
<tr>
<td><strong>禁止存储大文件或者大照片</strong><br>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存 URI 多好。</td>
</tr>
<tr>
<td><strong>控制单表数据量，单表记录控制在千万级</strong></td>
</tr>
<tr>
<td><strong>平衡范式与冗余，为提高效率可以牺牲范式设计，冗余数据</strong></td>
</tr>
</tbody></table>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><table>
<thead>
<tr>
<th><strong>只允许使用内网域名，而不是 ip 连接数据库</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>线上环境、开发环境、测试环境数据库内网域名遵循命名规范</strong><br>业务名称：xxx<br>线上环境：dj.xxx.db<br>开发环境：dj.xxx.rdb<br>测试环境：dj.xxx.tdb<br>从库在名称后加-s标识，备库在名称后加-ss标识线上<br>从库：dj.xxx-s.db<br>线上备库：dj.xxx-sss.db</td>
</tr>
<tr>
<td><strong>库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用</strong></td>
</tr>
<tr>
<td><strong>表名 t_xxx，非唯一索引名 idx_xxx，唯一索引名 uniq_xxx</strong></td>
</tr>
</tbody></table>
<h3 id="表设计规范"><a href="#表设计规范" class="headerlink" title="表设计规范"></a>表设计规范</h3><table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>单实例表个数必须控制在2000个以内</strong></td>
</tr>
<tr>
<td><strong>单表分表个数必须控制在1024个以内</strong></td>
</tr>
<tr>
<td><strong>单表列数目必须小于30</strong></td>
</tr>
<tr>
<td><strong>表必须有主键，例如自增主键，推荐使用 UNSIGNED 整数为主键</strong><br>解读：主键递增，数据行写入可以提高插入性能，可以避免 page 分裂，减少表碎片，提升空间和内存的使用；主键要选择较短的数据类型，InnoDB 引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率；无主键的表删除，在 row 模式的主从架构，会导致备库夯住；</td>
</tr>
<tr>
<td><strong>禁止使用外键，如果有外键完整性约束，需要应用程序控制</strong><br>解读：外键会导致表与表之间耦合，update 与 delete 操作都会涉及相关联的表，十分影响 SQL 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先。</td>
</tr>
<tr>
<td><strong>建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据</strong></td>
</tr>
</tbody></table>
<h3 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a>字段设计规范</h3><table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>必须把字段定义为 NOT NULL 并且提供默认值</strong><br>解读：null 的列使索引/索引统计/值比较都更加复杂，对 MySQL 来说更难优化；null 这种类型 MySQL 内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多；null 值需要更多的存储空，无论是表还是索引中每行中的 null 的列都需要额外的空间来标识；对 null 的处理时候，只能采用 is null 或 is not null，而不能采用 =、in、&lt;、&lt;&gt;、!=、not in 这些操作符号。如：where name != ‘shenjian’，如果存在 name 为 null 值的记录，查询结果就不会包含 name 为 null 值的记录；</td>
</tr>
<tr>
<td><strong>禁止使用 TEXT、BLOB 类型</strong><br>解读：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能。</td>
</tr>
<tr>
<td><strong>禁止使用小数存储货币</strong><br>解读：使用整数吧，小数容易导致钱对不上。</td>
</tr>
<tr>
<td><strong>必须使用 varchar(20) 存储手机号</strong><br>解读：涉及到区号或者国家代号，可能出现+-()；varchar 可以支持模糊查询，例如：like“138%”；</td>
</tr>
<tr>
<td><strong>禁止使用 ENUM，可使用 TINYINT 代替</strong><br>解读：增加新的 ENUM 值要做 DDL 操作；ENUM 的内部实际存储就是整数；</td>
</tr>
<tr>
<td><strong>用好数值类型</strong><br>解读：tinyint（1Byte）：有符号（signed）范围是-128到127，无符号（unsigned）范围是0到255。smallint（2Byte）：有符号（signed）范围是-32768到32767，无符号（unsigned）范围是0到65535。mediumint（3Byte）：有符号（signed）范围是-8388608到8388607，无符号（unsigned）范围是0到16777215。int（4Byte）：有符号（signed）范围是-2147483648到2147483647，无符号（unsigned）范围是0到4294967295bigint（8Byte）：有符号（signed）范围是-9223372036854775808到9223372036854775807，无符号（unsigned）范围是0到18446744073709551615</td>
</tr>
<tr>
<td><strong>使用</strong> <strong>INT UNSIGNED</strong> <strong>存储</strong> <strong>IPv4</strong>，不要用 <strong>char(15)</strong></td>
</tr>
<tr>
<td><strong>根据业务区分使用</strong> <strong>char/varchar</strong><br>解读：字段长度固定，或者长度近似的业务场景，适合使用 char，能够减少碎片，查询性能高；字段长度相差较大，或者更新较少的业务场景，适合使用 varchar，能够减少空间；</td>
</tr>
<tr>
<td><strong>根据业务区分使用 datetime/timestamp</strong><br>解读：前者占用5个字节，后者占用4个字节，存储年使用 YEAR，存储日期使用 DATE，存储时间使用 datetime</td>
</tr>
</tbody></table>
<h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><table>
<thead>
<tr>
<th><strong>单表索引建议控制在5个以内</strong><br>解读：<br>互联网高并发业务，太多索引会影响写性能；<br>生成执行计划时，如果索引太多，会降低性能，并可能导致 MySQL 选择不到最优索引；<br>异常复杂的查询需求，可以选择 ES 等更为适合的方式存</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单索引字段数不允许超过5个</strong><br>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了。</td>
</tr>
<tr>
<td><strong>禁止在更新十分频繁、区分度不高的属性上建立索引</strong><br>解读：更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能；【性别】这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似；</td>
</tr>
<tr>
<td><strong>建立组合索引，必须把区分度高的字段放在前面</strong><br>解读：能够更加有效的过滤数据。</td>
</tr>
<tr>
<td><strong>非必要不要进行</strong> <strong>JOIN</strong> <strong>查询，如果要进行</strong> <strong>JOIN</strong> <strong>查询，被</strong> <strong>JOIN</strong> <strong>的字段必须类型相同，并建立索引。</strong></td>
</tr>
<tr>
<td><strong>理解组合索引最左前缀原则，避免重复建设索引</strong>，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)</td>
</tr>
</tbody></table>
<h3 id="SQL-使用规范"><a href="#SQL-使用规范" class="headerlink" title="SQL 使用规范"></a>SQL 使用规范</h3><table>
<thead>
<tr>
<th><strong>禁止使用 SELECT *，只获取必要的字段，需要显示说明列属性</strong><br>解读：<br>读取不需要的列会增加 CPU、IO、内存、网络带宽消耗；<br>不能有效的利用覆盖索引；<br>使用 SELECT * 容易在增加或者删除字段后出现程序 BUG；</th>
</tr>
</thead>
<tbody><tr>
<td><strong>禁止使用 INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性</strong><br>解读：容易在增加或者删除字段后出现程序BUG。</td>
</tr>
<tr>
<td><strong>禁止使用属性隐式转换</strong><br>解读：WHERE 子句中出现 COLUMN 字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定 WHERE 中的参数类型。SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中 phone 索引。</td>
</tr>
<tr>
<td><strong>禁止在 WHERE 条件的属性上使用函数或者表达式</strong><br>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描。正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)。</td>
</tr>
<tr>
<td><strong>禁止负向查询，以及%开头的模糊查询</strong><br>解读：负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE 等，会导致全表扫描；%开头的模糊查询，会导致全表扫描；</td>
</tr>
<tr>
<td><strong>禁止大表使用 JOIN 查询，禁止大表使用子查询</strong><br>解读：会产生临时表，消耗较多内存与 CPU，极大影响数据库性能。</td>
</tr>
<tr>
<td><strong>禁止使用 OR 条件，必须改为 IN 查询或者</strong> <strong>UNION</strong> <strong>查询，IN</strong> <strong>的值必须少于50个</strong><br>解读：旧版本 MySQL 的 OR 查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的 CPU 帮助实施查询优化呢。</td>
</tr>
<tr>
<td><strong>尽量使用 UNION ALL 替代 UNION，UNION 有去重开销</strong><br>解读：UNION 和 UNION ALL 的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的 CPU 运算，加大资源消耗及延迟。当然，使用 UNION ALL 的前提条件是两个结果集没有重复数据。</td>
</tr>
<tr>
<td><strong>LIMIT 高效分页（可选）</strong><br>解读：LIMIE 越大，效率越低，SELECT id FROM t LIMIE 10000, 10; 改为 SELECT id FROM t WHERE id &gt; 10000 LIMIT 10;。</td>
</tr>
<tr>
<td><strong>SQL WHERE 条件的顺序不一定需要按照索引的顺序</strong><br>解读：比如一个联合索引是 name, age，查询的时候 WHERE 条件可以写成 age=10 and name=’张三’。</td>
</tr>
<tr>
<td><strong>当只需要处理一条数据的时候，请使用 LIMIT 1</strong><br>解读：这是为了使 EXPLAIN 中 type 列达到 const 类型；SELECT、UPDATE、DELETE 操作在只需要处理一条数据的时候都可以加上 LIMIT 1；</td>
</tr>
<tr>
<td><strong>区分 IN 和 EXISTS 的使用场景</strong><br>解读：SELECT * FROM table_a WHERE id IN (SELECT id FROM table_b)上面 SQL 语句相当于：SELECT * FROM table_a WHERE EXISTS (SELECT * FROM table_b WHERE table_b.id = table_a.id)  区分 IN 和 EXISTS 的使用场景，主要参考两者的驱动顺序（这时性能变化的关键）。如果是 IN，会以内层表为驱动表，先执行子查询，所以 IN 适合外表大而内表小的情况；如果是 EXISTS，会以外层表为驱动表，先执行外表，所以 EXISTS 适合外表小而内表大的情况。</td>
</tr>
<tr>
<td><strong>区分 NOT IN 和 NOT</strong> <strong>EXISTS 的使用场景</strong><br>解读：关于 NOT IN 和 NOT EXISTS，推荐使用 NOT EXISTS，不仅仅是效率问题，NOT IN 可能存在逻辑问题。</td>
</tr>
<tr>
<td><strong>使用左关联的写法代替 NOT EXISTS</strong><br>解读：原 SQL 语句：SELECT * FROM table_a WHERE NOT EXISTS (SELECT * FROM table_b WHERE table_b.id = table_a.id)高效的 SQL 语句：SELECT * FROM table_a LEFT JOIN table_b ON table_a.id = table_b.id WHERE table_b.id IS NULL</td>
</tr>
<tr>
<td><strong>避免在 WHERE 子句中对字段进行 NULL 值判断</strong><br>解读：对于 NULL 的判断会导致引擎放弃使用索引而进行全表扫描。</td>
</tr>
<tr>
<td><strong>对于组合索引来说，WHERE 条件要遵守最左前缀法则</strong><br>解读：例如索引含有字段 id、name、school，可以使用 id 字段查询，也可以使用 id、name 字段查询，但是使用 name 和 school 都无法命中这个索引。</td>
</tr>
<tr>
<td><strong>必要时可以使用 FORCE INDEX 来强制查询走某个索引（谨慎使用）</strong><br>解读：有的时候 MySQL 优化器采取它认为合适的索引来检索 SQL 语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用 FORCE INDEX 来强制优化器使用我们制定的索引。</td>
</tr>
<tr>
<td><strong>关于 JOIN 的优化</strong><br>解读：LEFT JOIN：左表是驱动表，右表是被驱动表RIGHT JOIN：右表时驱动表，左表是驱动表INNER JOIN：MySQL 会选择数据量比较小的表作为驱动表，大表作为被驱动表优化原则：尽量使用 INNER JOIN ，避免 LEFT JOIN &amp; RIGHT JOIN被驱动表的索引字段作为 ON 的限制字段利用小表去驱动大表</td>
</tr>
<tr>
<td><strong>巧用 STRAIGHT_JOIN（谨慎使用）</strong><br>解读：INNER JOIN 是由 MySQL 选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有 GROUP BY、ORDER BY 等 Using filesort、Using temporary时。STRAIGHT_JOIN 来强制连接顺序，在 STRAIGHT_JOIN 左边的表名就是驱动表，右边则是被驱动表。在使用 STRAIGHT_JOIN 有个前提条件是该查询是内连接，也就是 INNER JOIN。其他链接不推荐使用 STRAIGHT_JOIN，否则可能造成查询结果不准确。</td>
</tr>
<tr>
<td><strong>应用程序必须捕获 SQL 异常，并有相应处理</strong></td>
</tr>
</tbody></table>
<p>原文出处：<a href="https://www.yuque.com/yinjianwei/vyrvkf/mpu8gk" target="_blank" rel="noopener">Mysql军规</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/04/28/Mysql-rules/" data-id="ck9qswfqg00152cugf8o09nre" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sql-execution-process" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/28/sql-execution-process/" class="article-date">
  <time datetime="2020-04-28T09:09:01.000Z" itemprop="datePublished">2020-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/sql-execution-process/">Sql语句的执行过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>说起MySQL的查询优化，相信大家收藏了一堆奇技淫巧：不能使用SELECT *、不使用NULL字段、合理创建索引、为字段选择合适的数据类型….. 你是否真的理解这些优化技巧？是否理解其背后的工作原理？在实际场景下性能真有提升吗？我想未必。因而理解这些优化建议背后的原理就尤为重要，希望本文能让你重新审视这些优化建议，并在实际业务场景下合理的运用。</p>
<h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><p>如果能在头脑中构建一幅MySQL各组件之间如何协同工作的架构图，有助于深入理解MySQL服务器。下图展示了MySQL的逻辑架构图。</p>
<img src="/2020/04/28/sql-execution-process/1.jpg" class title="ss">

<p>MySQL逻辑架构整体分为三层，<strong>最上层为客户端层</strong>，并非MySQL所独有，诸如：<strong>连接处理、授权认证、安全</strong>等功能均在这一层处理。<br>MySQL大多数核心服务均在<strong>中间</strong>这一层，包括查询<strong>解析、分析、优化、缓存、内置函数</strong>(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。<br><strong>最下层为存储引擎</strong>，其负责MySQL中的<strong>数据存储和提取</strong>。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。<br>MySQL查询过程<br>我们总是希望MySQL能够获得更高的查询性能，最好的办法是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，就会发现：<strong>很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。</strong><br>当向MySQL发送一个请求的时候，MySQL到底做了些什么呢？</p>
<img src="/2020/04/28/sql-execution-process/2.jpg" class title="ss">

<h2 id="MySQL查询过程"><a href="#MySQL查询过程" class="headerlink" title="MySQL查询过程"></a>MySQL查询过程</h2><p><strong>客户端/服务端通信协议</strong><br><strong>MySQL客户端/服务端通信协议是“半双工”的</strong>：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这<strong>两个动作不能同时发生</strong>。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。</p>
<p>客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置max_allowed_packet参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。</p>
<p>与之相反的是，<strong>服务器响应给用户的数据</strong>通常会很多，由<strong>多个数据包组成</strong>。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用SELECT *以及加上LIMIT限制的原因之一。</p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>在解析一个查询语句前，如果查询缓存是打开的，那么MySQL会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。</p>
<p><strong>MySQL将缓存存放在一个引用表</strong>（不要理解成table，可以认为是类似于HashMap的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。</p>
<p>如果查询中包含任何用户<strong>自定义函数、存储函数、用户变量、临时表、mysql库中的系统表</strong>，其查询结果都不会被缓存。比如函数NOW()或者CURRENT_DATE()会因为不同的查询时间，返回不同的查询结果，再比如包含CURRENT_USER或者CONNECION_ID()的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。</p>
<p>既然是<strong>缓存</strong>，就会失效，那查询缓存何时失效呢？MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。<strong>如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗</strong>，甚至导致系统僵死一会儿。而且查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外：</p>
<ol>
<li><strong>任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存</strong></li>
<li><strong>如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗</strong></li>
</ol>
<p>基于此，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。但要如何评估打开缓存是否能够带来性能提升是一件非常困难的事情，也不在本文讨论的范畴内。如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化，比如：</p>
<ol>
<li><strong>用多个小表代替一个大表，注意不要过度设计</strong></li>
<li><strong>批量插入代替循环单条插入</strong></li>
<li><strong>合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适</strong></li>
<li><strong>可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存</strong></li>
</ol>
<p>最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。</p>
<p>当然查询缓存系统本身是非常复杂的，这里讨论的也只是很小的一部分，其他更深入的话题，比如：缓存是如何使用内存的？如何控制内存的碎片化？事务对查询缓存有何影响等等，读者可以自行阅读相关资料，这里权当抛砖引玉吧。</p>
<p><strong>因为文章篇幅过长，希望您能读到最后，对你一定是有帮助的，文末有彩蛋哦，分享大量mysql面试资料以及各个专项面试资料给大家！</strong></p>
<h2 id="语法解析和预处理"><a href="#语法解析和预处理" class="headerlink" title="语法解析和预处理"></a>语法解析和预处理</h2><p>MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等等。</p>
<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><p>经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成查询计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好的执行计划。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t_message limit 10;</span><br><span class="line">...省略结果集</span><br><span class="line">mysql&gt; show status like 'last_query_cost';</span><br><span class="line">+<span class="comment">-----------------+-------------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">-----------------+-------------+</span></span><br><span class="line">| Last_query_cost | 6391.799000 |</span><br><span class="line">+<span class="comment">-----------------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>示例中的结果表示优化器认为大概需要做6391个数据页的随机查找才能完成上面的查询。这个结果是根据一些列的统计信息计算得来的，这些统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。</p>
<p>有非常多的原因会导致MySQL选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、MySQL认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但MySQL值选择它认为成本小的，但成本小并不意味着执行时间短）等等。</p>
<p><strong>MySQL的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：</strong></p>
<ul>
<li>重新定义表的关联顺序（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序）</li>
<li>优化MIN()和MAX()函数（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值，具体原理见下文）</li>
<li>提前终止查询（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询）</li>
<li>优化排序（在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多）</li>
</ul>
<p>随着MySQL的不断发展，优化器使用的优化策略也在不断的进化，这里仅仅介绍几个非常常用且容易理解的优化策略，其他的优化策略，大家自行查阅吧。</p>
<h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>在完成解析和优化阶段以后，MySQL会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为handler API。查询过程中的每一张表由一个handler实例表示。实际上，MySQL在查询优化阶段就为每一张表创建了一个handler实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但其底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作。</p>
<h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>查询执行的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等等。</p>
<p>如果查询缓存被打开且这个查询可以被缓存，MySQL也会将结果存放到缓存中。</p>
<p><strong>结果集返回客户端是一个增量且逐步返回的过程</strong>。有可能MySQL在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。需要注意的是，结果集中的每一行都会以一个满足①中所描述的通信协议的数据包发送，再通过TCP协议进行传输，在传输过程中，可能对MySQL的数据包进行缓存然后批量发送。</p>
<p><strong>回头总结一下MySQL整个查询执行过程，总的来说分为6个步骤</strong>：</p>
<ol>
<li>客户端向MySQL服务器发送一条查询请求</li>
<li>服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li>
<li>服务器进行SQL解析、预处理、再由优化器生成对应的执行计划</li>
<li>MySQL根据执行计划，调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端，同时缓存查询结果</li>
</ol>
<p>性能优化建议<br>看了这么多，你可能会期待给出一些优化手段，是的，下面会从3个不同方面给出一些优化建议。但请等等，还有一句忠告要先送给你：<strong>不要听信你看到的关于优化的“绝对真理”，包括本文所讨论的内容，而应该是在实际的业务场景下通过测试来验证你关于执行计划以及响应时间的假设</strong>。</p>
<p>原文出处：<a href="https://zhuanlan.zhihu.com/p/72855648" target="_blank" rel="noopener">读完这篇彻底弄清楚MySQL优化问题</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/04/28/sql-execution-process/" data-id="ck9qswfqp001v2cug728re4j3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-b-tree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/28/b-tree/" class="article-date">
  <time datetime="2020-04-28T04:08:51.000Z" itemprop="datePublished">2020-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/b-tree/">B+树图文讲解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载自：<a href="https://www.sohu.com/a/156886901_479559" target="_blank" rel="noopener">伯乐专栏作者/玻璃猫，微信公众号 - 梦见 漫画：什么是b+树</a></p>
<p>这一次我们来介绍 B+ 树。</p>
<img src="/2020/04/28/b-tree/1.jpg" class title="t">

<img src="/2020/04/28/b-tree/2.jpg" class title="t">

<img src="/2020/04/28/b-tree/3.jpg" class title="t">

<img src="/2020/04/28/b-tree/4.jpg" class title="t">

<p><strong>一个m阶的B树具有如下几个特征：</strong></p>
<p>1.根结点至少有两个子女。</p>
<p>2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m</p>
<p>3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m</p>
<p>4.所有的叶子结点都位于同一层。</p>
<p>5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</p>
<img src="/2020/04/28/b-tree/5.jpg" class title="t">

<p><strong>一个m阶的B+树具有如下几个特征：</strong></p>
<p>1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</p>
<p>2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
<p>3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p>
<img src="/2020/04/28/b-tree/6.jpg" class title="t">

<img src="/2020/04/28/b-tree/7.jpg" class title="t">

<img src="/2020/04/28/b-tree/8.jpg" class title="t">

<img src="/2020/04/28/b-tree/9.jpg" class title="t">

<img src="/2020/04/28/b-tree/10.jpg" class title="t">

<img src="/2020/04/28/b-tree/11.jpg" class title="t">

<img src="/2020/04/28/b-tree/12.jpg" class title="t">

<img src="/2020/04/28/b-tree/13.jpg" class title="t">

<img src="/2020/04/28/b-tree/14.jpg" class title="t">

<img src="/2020/04/28/b-tree/15.jpg" class title="t">

<img src="/2020/04/28/b-tree/16.jpg" class title="t">

<img src="/2020/04/28/b-tree/17.jpg" class title="t">

<img src="/2020/04/28/b-tree/18.jpg" class title="t">

<img src="/2020/04/28/b-tree/19.jpg" class title="t">

<img src="/2020/04/28/b-tree/20.jpg" class title="t">

<img src="/2020/04/28/b-tree/21.jpg" class title="t">

<img src="/2020/04/28/b-tree/22.jpg" class title="t">

<img src="/2020/04/28/b-tree/23.jpg" class title="t">

<img src="/2020/04/28/b-tree/24.jpg" class title="t">

<img src="/2020/04/28/b-tree/25.jpg" class title="t">

<img src="/2020/04/28/b-tree/26.jpg" class title="t">

<img src="/2020/04/28/b-tree/27.jpg" class title="t">

<img src="/2020/04/28/b-tree/28.jpg" class title="t">

<img src="/2020/04/28/b-tree/29.jpg" class title="t">

<img src="/2020/04/28/b-tree/30.jpg" class title="t">

<img src="/2020/04/28/b-tree/31.jpg" class title="t">

<img src="/2020/04/28/b-tree/32.jpg" class title="t">

<img src="/2020/04/28/b-tree/33.jpg" class title="t">

<img src="/2020/04/28/b-tree/34.jpg" class title="t">

<img src="/2020/04/28/b-tree/35.jpg" class title="t">

<img src="/2020/04/28/b-tree/36.jpg" class title="t">

<img src="/2020/04/28/b-tree/37.jpg" class title="t">

<img src="/2020/04/28/b-tree/38.jpg" class title="t">

<img src="/2020/04/28/b-tree/39.jpg" class title="t">

<img src="/2020/04/28/b-tree/40.jpg" class title="t">

<img src="/2020/04/28/b-tree/41.jpg" class title="t">

<img src="/2020/04/28/b-tree/42.jpg" class title="t">

<img src="/2020/04/28/b-tree/43.jpg" class title="t">

<img src="/2020/04/28/b-tree/44.jpg" class title="t">

<img src="/2020/04/28/b-tree/45.jpg" class title="t">

<img src="/2020/04/28/b-tree/46.jpg" class title="t">

<img src="/2020/04/28/b-tree/47.jpg" class title="t">

<img src="/2020/04/28/b-tree/48.jpg" class title="t">

<p><strong>B+树的特征：</strong></p>
<p>1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</p>
<p>2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
<p>3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p>
<p><strong>B+树的优势：</strong></p>
<p>1.单一节点存储更多的元素，使得查询的IO次数更少。</p>
<p>2.所有查询都要查找到叶子节点，查询性能稳定。</p>
<p>3.所有叶子节点形成有序链表，便于范围查询。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/liqiang1127/2020/04/28/b-tree/" data-id="ck9qswfqf00122cug456mcifv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" rel="tag">网络通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 16.67px;">JVM</a> <a href="/tags/LeetCode/" style="font-size: 18.33px;">LeetCode</a> <a href="/tags/Linux/" style="font-size: 11.67px;">Linux</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/mysql/" style="font-size: 20px;">mysql</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 13.33px;">并发编程</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.33px;">数据结构</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" style="font-size: 13.33px;">网络通信</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 11.67px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/24/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/">JVM面试题</a>
          </li>
        
          <li>
            <a href="/2020/06/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/">数据库设计三范式</a>
          </li>
        
          <li>
            <a href="/2020/06/24/applicationContext%E4%B8%AD%E7%9A%84Refresh-%E6%96%B9%E6%B3%95/">applicationContext中的Refresh()方法</a>
          </li>
        
          <li>
            <a href="/2020/06/23/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%E5%A4%A7%E6%80%BB%E7%BB%93/">阻塞队列存取方法区别大总结</a>
          </li>
        
          <li>
            <a href="/2020/06/22/synchronized%E5%92%8CLock%E5%AD%B0%E4%BC%98%E5%AD%B0%E5%8A%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F/">synchronized和Lock孰优孰劣，如何选择？</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 liqiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>